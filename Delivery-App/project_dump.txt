Exception calling "WriteAllBytes" with "2" argument(s): "The process cannot access the file 'C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\project_dump.
txt' because it is being used by another process."
At line:1 char:1
+ [System.IO.File]::WriteAllBytes('project_dump.txt',[byte[]](239,187,1 ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException
    + FullyQualifiedErrorId : IOException
 
=== Dump started: 01.09.2025  8:45:06,14
Root: C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   body.json
|   cookies.txt
|   docker-compose.yml
|   dump_project.bat
|   project_dump.txt
|   pyproject.toml
|   
+---application
|   |   __init__.py
|   |   
|   +---contracts
|   |       package_dto.py
|   |       pagination.py
|   |       __init__.py
|   |       
|   \---use_cases
|           get_packages.py
|           get_package_details.py
|           get_package_types.py
|           register_package.py
|           __init__.py
|           
+---bootstrap
|       asgi.py
|       main.py
|       __init__.py
|       
+---core
|       config.py
|       exceptions.py
|       __init__.py
|       
+---docker
|       app.Dockerfile
|       
+---domain
|   |   __init__.py
|   |   
|   +---entities
|   |       package.py
|   |       package_type.py
|   |       __init__.py
|   |       
|   +---ports
|   |       currency_rates_provider.py
|   |       package_repository.py
|   |       package_type_repository.py
|   |       session_repository.py
|   |       __init__.py
|   |       
|   +---services
|   |       delivery_pricing.py
|   |       __init__.py
|   |       
|   \---value_objects
|           currency.py
|           identifiers.py
|           __init__.py
|           
+---infrastructure
|   |   __init__.py
|   |   
|   +---database
|   |       init_db.py
|   |       __init__.py
|   |       
|   +---external
|   |       cached_provider.py
|   |       cbr_provider.py
|   |       __init__.py
|   |       
|   +---logging
|   |       config.py
|   |       __init__.py
|   |       
|   +---redis
|   |       client.py
|   |       
|   +---security
|   |       redis_session_repository.py
|   |       __init__.py
|   |       
|   +---sqlalchemy
|   |       database.py
|   |       models.py
|   |       package_repository.py
|   |       package_type_repository.py
|   |       __init__.py
|   |       
|   \---tasks
|           celery_app.py
|           currency_tasks.py
|           delivery_tasks.py
|           __init__.py
|           
+---logs
|       app.log
|       errors.log
|       flower.db
|       
+---migrations
|   |   alembic.ini
|   |   
|   \---alembic
|       |   env.py
|       |   script.py.mako
|       |   
|       \---versions
|               001_create_package_tables.py
|               
+---presentation
|   |   fastapi.py
|   |   __init__.py
|   |   
|   +---dependencies
|   |       container.py
|   |       di_deps.py
|   |       session_deps.py
|   |       __init__.py
|   |       
|   +---middleware
|   |       error_middleware.py
|   |       logging_middleware.py
|   |       __init__.py
|   |       
|   +---routers
|   |       delivery.py
|   |       health.py
|   |       packages.py
|   |       package_types.py
|   |       __init__.py
|   |       
|   \---schemas
|           delivery_schemas.py
|           error_schemas.py
|           health_schemas.py
|           package_schemas.py
|           package_type_schemas.py
|           __init__.py
|           
\---tests
        test_delivery_pricing.py
        

=== FILE CONTENTS ========================================
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\.env --------------------
# Переменные окружения для Delivery App

# Основные настройки приложения
APP_NAME=Delivery App
DEBUG=true
HOST=0.0.0.0
PORT=8000

# База данных PostgreSQL
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=delivery_app

# Redis
REDIS_URL=redis://localhost:6379/0
REDIS_TTL=300

# Celery
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# CBR API
CBR_API_URL=https://www.cbr-xml-daily.ru/daily_json.js
CBR_TIMEOUT=10
CBR_RETRY_COUNT=3

# CORS
CORS_ORIGINS=["http://localhost:3000", "http://127.0.0.1:3000"]

# Security
SESSION_SECRET_KEY=your-secret-key-change-in-production
SESSION_COOKIE_NAME=delivery_session
SESSION_COOKIE_MAX_AGE=2592000
SESSION_COOKIE_SECURE=false
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SAMESITE=lax

# Документация
DOCS_URL=/docs
REDOC_URL=/redoc
OPENAPI_URL=/openapi.json

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\.env.example --------------------
# Переменные окружения для Delivery App

# Основные настройки приложения
APP_NAME=Delivery App
DEBUG=true
HOST=0.0.0.0
PORT=8000

# База данных PostgreSQL
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=delivery_app

# Redis
REDIS_URL=redis://localhost:6379/0
REDIS_TTL=300

# Celery
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# CBR API
CBR_API_URL=https://www.cbr-xml-daily.ru/daily_json.js
CBR_TIMEOUT=10
CBR_RETRY_COUNT=3

# CORS
CORS_ORIGINS=["http://localhost:3000", "http://127.0.0.1:3000"]

# Security
SESSION_SECRET_KEY=your-secret-key-change-in-production
SESSION_COOKIE_NAME=delivery_session
SESSION_COOKIE_MAX_AGE=2592000
SESSION_COOKIE_SECURE=false
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SAMESITE=lax

# Документация
DOCS_URL=/docs
REDOC_URL=/redoc
OPENAPI_URL=/openapi.json

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\body.json --------------------
﻿{"weight":"1.250","type_id":1,"name":"Test package","value_usd":"10.00"}
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\cookies.txt --------------------
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	FALSE	1759293125	delivery_session	323306c3-b0d9-4129-98eb-34b7be971914

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\docker-compose.yml --------------------
services:
  db:
    image: postgres:15-alpine
    container_name: delivery_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
    ports: ["5432:5432"]
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d delivery_app || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10

  redis:
    image: redis:7-alpine
    container_name: delivery_redis
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 10

  rabbitmq:
    image: rabbitmq:3-management
    container_name: delivery_rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: ["CMD-SHELL", "rabbitmq-diagnostics -q ping"]
      interval: 10s
      timeout: 5s
      retries: 10

  # Применяем миграции один раз перед запуском остальных сервисов
  migrate:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_migrate
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "alembic -c migrations/alembic.ini upgrade head"
    restart: "no"

  api:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_api
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: uvicorn bootstrap.asgi:app --host 0.0.0.0 --port 8000 --proxy-headers
    ports: ["8000:8000"]
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  worker:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_worker
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app worker -l info -Q celery --hostname=delivery-worker@%h -E"
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  scheduler:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_scheduler
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app beat -l info"
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  flower:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_flower
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app flower --port=5555 --persistent --db=/app/logs/flower.db"
    volumes:
      - ./logs:/app/logs
    ports: ["5555:5555"]
    restart: unless-stopped

volumes:
  postgres_data:

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\dump_project.bat --------------------
@echo off
setlocal EnableExtensions
chcp 65001 >nul

if "%~1"=="" (
  set "OUT=project_dump.txt"
) else (
  set "OUT=%~1"
)

REM записываем BOM (0xEFBBBF) в начало
> "%OUT%" powershell -Command "[System.IO.File]::WriteAllBytes('%OUT%',[byte[]](239,187,191))"

>>"%OUT%" echo === Dump started: %date% %time%
>>"%OUT%" echo Root: %cd%
>>"%OUT%" echo.

>>"%OUT%" echo === DIRECTORY TREE =======================================
tree /F /A >> "%OUT%"
>>"%OUT%" echo.
>>"%OUT%" echo === FILE CONTENTS ========================================

for /R %%F in (*) do (
  echo %%~fF | findstr /I "\\.git\\" >nul
  if errorlevel 1 (
    >>"%OUT%" echo -------------------- %%~fF --------------------
    type "%%F" >> "%OUT%"
    >>"%OUT%" echo.
  )
)

>>"%OUT%" echo === Done: %date% %time%
echo Готово: "%OUT%"

endlocal

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\project_dump.txt --------------------
Exception calling "WriteAllBytes" with "2" argument(s): "The process cannot access the file 'C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\project_dump.
txt' because it is being used by another process."
At line:1 char:1
+ [System.IO.File]::WriteAllBytes('project_dump.txt',[byte[]](239,187,1 ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException
    + FullyQualifiedErrorId : IOException
 
=== Dump started: 01.09.2025  8:45:06,14
Root: C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   body.json
|   cookies.txt
|   docker-compose.yml
|   dump_project.bat
|   project_dump.txt
|   pyproject.toml
|   
+---application
|   |   __init__.py
|   |   
|   +---contracts
|   |       package_dto.py
|   |       pagination.py
|   |       __init__.py
|   |       
|   \---use_cases
|           get_packages.py
|           get_package_details.py
|           get_package_types.py
|           register_package.py
|           __init__.py
|           
+---bootstrap
|       asgi.py
|       main.py
|       __init__.py
|       
+---core
|       config.py
|       exceptions.py
|       __init__.py
|       
+---docker
|       app.Dockerfile
|       
+---domain
|   |   __init__.py
|   |   
|   +---entities
|   |       package.py
|   |       package_type.py
|   |       __init__.py
|   |       
|   +---ports
|   |       currency_rates_provider.py
|   |       package_repository.py
|   |       package_type_repository.py
|   |       session_repository.py
|   |       __init__.py
|   |       
|   +---services
|   |       delivery_pricing.py
|   |       __init__.py
|   |       
|   \---value_objects
|           currency.py
|           identifiers.py
|           __init__.py
|           
+---infrastructure
|   |   __init__.py
|   |   
|   +---database
|   |       init_db.py
|   |       __init__.py
|   |       
|   +---external
|   |       cached_provider.py
|   |       cbr_provider.py
|   |       __init__.py
|   |       
|   +---logging
|   |       config.py
|   |       __init__.py
|   |       
|   +---redis
|   |       client.py
|   |       
|   +---security
|   |       redis_session_repository.py
|   |       __init__.py
|   |       
|   +---sqlalchemy
|   |       database.py
|   |       models.py
|   |       package_repository.py
|   |       package_type_repository.py
|   |       __init__.py
|   |       
|   \---tasks
|           celery_app.py
|           currency_tasks.py
|           delivery_tasks.py
|           __init__.py
|           
+---logs
|       app.log
|       errors.log
|       flower.db
|       
+---migrations
|   |   alembic.ini
|   |   
|   \---alembic
|       |   env.py
|       |   script.py.mako
|       |   
|       \---versions
|               001_create_package_tables.py
|               
+---presentation
|   |   fastapi.py
|   |   __init__.py
|   |   
|   +---dependencies
|   |       container.py
|   |       di_deps.py
|   |       session_deps.py
|   |       __init__.py
|   |       
|   +---middleware
|   |       error_middleware.py
|   |       logging_middleware.py
|   |       __init__.py
|   |       
|   +---routers
|   |       delivery.py
|   |       health.py
|   |       packages.py
|   |       package_types.py
|   |       __init__.py
|   |       
|   \---schemas
|           delivery_schemas.py
|           error_schemas.py
|           health_schemas.py
|           package_schemas.py
|           package_type_schemas.py
|           __init__.py
|           
\---tests
        test_delivery_pricing.py
        

=== FILE CONTENTS ========================================
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\.env --------------------
# Переменные окружения для Delivery App

# Основные настройки приложения
APP_NAME=Delivery App
DEBUG=true
HOST=0.0.0.0
PORT=8000

# База данных PostgreSQL
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=delivery_app

# Redis
REDIS_URL=redis://localhost:6379/0
REDIS_TTL=300

# Celery
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# CBR API
CBR_API_URL=https://www.cbr-xml-daily.ru/daily_json.js
CBR_TIMEOUT=10
CBR_RETRY_COUNT=3

# CORS
CORS_ORIGINS=["http://localhost:3000", "http://127.0.0.1:3000"]

# Security
SESSION_SECRET_KEY=your-secret-key-change-in-production
SESSION_COOKIE_NAME=delivery_session
SESSION_COOKIE_MAX_AGE=2592000
SESSION_COOKIE_SECURE=false
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SAMESITE=lax

# Документация
DOCS_URL=/docs
REDOC_URL=/redoc
OPENAPI_URL=/openapi.json

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\.env.example --------------------
# Переменные окружения для Delivery App

# Основные настройки приложения
APP_NAME=Delivery App
DEBUG=true
HOST=0.0.0.0
PORT=8000

# База данных PostgreSQL
POSTGRES_USER=postgres
POSTGRES_PASSWORD=password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=delivery_app

# Redis
REDIS_URL=redis://localhost:6379/0
REDIS_TTL=300

# Celery
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# CBR API
CBR_API_URL=https://www.cbr-xml-daily.ru/daily_json.js
CBR_TIMEOUT=10
CBR_RETRY_COUNT=3

# CORS
CORS_ORIGINS=["http://localhost:3000", "http://127.0.0.1:3000"]

# Security
SESSION_SECRET_KEY=your-secret-key-change-in-production
SESSION_COOKIE_NAME=delivery_session
SESSION_COOKIE_MAX_AGE=2592000
SESSION_COOKIE_SECURE=false
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SAMESITE=lax

# Документация
DOCS_URL=/docs
REDOC_URL=/redoc
OPENAPI_URL=/openapi.json

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\body.json --------------------
﻿{"weight":"1.250","type_id":1,"name":"Test package","value_usd":"10.00"}
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\cookies.txt --------------------
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	FALSE	1759293125	delivery_session	323306c3-b0d9-4129-98eb-34b7be971914

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\docker-compose.yml --------------------
services:
  db:
    image: postgres:15-alpine
    container_name: delivery_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
    ports: ["5432:5432"]
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d delivery_app || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10

  redis:
    image: redis:7-alpine
    container_name: delivery_redis
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 10

  rabbitmq:
    image: rabbitmq:3-management
    container_name: delivery_rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: ["CMD-SHELL", "rabbitmq-diagnostics -q ping"]
      interval: 10s
      timeout: 5s
      retries: 10

  # Применяем миграции один раз перед запуском остальных сервисов
  migrate:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_migrate
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "alembic -c migrations/alembic.ini upgrade head"
    restart: "no"

  api:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_api
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: uvicorn bootstrap.asgi:app --host 0.0.0.0 --port 8000 --proxy-headers
    ports: ["8000:8000"]
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  worker:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_worker
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app worker -l info -Q celery --hostname=delivery-worker@%h -E"
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  scheduler:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_scheduler
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      POSTGRES_HOST: db
      POSTGRES_PORT: "5432"
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: delivery_app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app beat -l info"
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  flower:
    build:
      context: .
      dockerfile: docker/app.Dockerfile
    container_name: delivery_flower
    depends_on:
      migrate:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      PYTHONPATH: /app
      CELERY_BROKER_URL: amqp://guest:guest@rabbitmq:5672//
      CELERY_RESULT_BACKEND: redis://redis:6379/1
      REDIS_URL: redis://redis:6379/0
    command: bash -lc "celery -A infrastructure.tasks.celery_app flower --port=5555 --persistent --db=/app/logs/flower.db"
    volumes:
      - ./logs:/app/logs
    ports: ["5555:5555"]
    restart: unless-stopped

volumes:
  postgres_data:

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\dump_project.bat --------------------
@echo off
setlocal EnableExtensions
chcp 65001 >nul

if "%~1"=="" (
  set "OUT=project_dump.txt"
) else (
  set "OUT=%~1"
)

REM записываем BOM (0xEFBBBF) в начало
> "%OUT%" powershell -Command "[System.IO.File]::WriteAllBytes('%OUT%',[byte[]](239,187,191))"

>>"%OUT%" echo === Dump started: %date% %time%
>>"%OUT%" echo Root: %cd%
>>"%OUT%" echo.

>>"%OUT%" echo === DIRECTORY TREE =======================================
tree /F /A >> "%OUT%"
>>"%OUT%" echo.
>>"%OUT%" echo === FILE CONTENTS ========================================

for /R %%F in (*) do (
  echo %%~fF | findstr /I "\\.git\\" >nul
  if errorlevel 1 (
    >>"%OUT%" echo -------------------- %%~fF --------------------
    type "%%F" >> "%OUT%"
    >>"%OUT%" echo.
  )
)

>>"%OUT%" echo === Done: %date% %time%
echo Готово: "%OUT%"

endlocal

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\project_dump.txt --------------------
E
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\pyproject.toml --------------------
[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "delivery-app"
version = "1.0.0"
description = "API для расчёта стоимости доставки посылок"
authors = ["Your Name <your.email@example.com>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = "^3.12"
fastapi = "^0.104.1"
uvicorn = {extras = ["standard"], version = "^0.24.0"}
sqlalchemy = {extras = ["asyncio"], version = "^2.0.23"}
asyncpg = "^0.29.0"
alembic = "^1.12.1"
pydantic = {extras = ["email"], version = "^2.5.0"}
pydantic-settings = "^2.1.0"
celery = "^5.3.4"
flower = "^2.0.1"
loguru = "^0.7.2"
httpx = "^0.25.2"
redis = "^5.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.3"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.11.0"
isort = "^5.12.0"
flake8 = "^6.1.0"
mypy = "^1.7.1"
pre-commit = "^3.6.0"

[tool.black]
line-length = 88
target-version = ['py312']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
known_first_party = ["core", "domain", "application", "infrastructure", "presentation"]

[tool.mypy]
python_version = "3.12"
check_untyped_defs = true
disallow_any_generics = true
disallow_incomplete_defs = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true

[[tool.mypy.overrides]]
module = [
    "celery.*",
    "sqlalchemy.*",
    "alembic.*"
]
ignore_missing_imports = true

[tool.pytest.ini_options]
testpaths = ["tests"]
asyncio_mode = "auto"
addopts = [
    "--strict-markers",
    "--strict-config",
    "--cov=.",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-report=xml",
]
markers = [
    "unit: Unit tests",
    "integration: Integration tests",
    "api: API tests"
]

-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\__init__.py --------------------
# Application модуль - оркестрация use-case-ов
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\contracts\package_dto.py --------------------
"""
Контракты UC для работы с посылками (Pydantic v2).
"""
from decimal import Decimal
from typing import Optional
from datetime import datetime

from pydantic import BaseModel, Field, computed_field


class CreatePackageDTO(BaseModel):
    """Данные для создания посылки."""
    name: str
    weight: Decimal
    type_id: int
    value_usd: Decimal
    session_id: str


class PackageDTO(BaseModel):
    """Данные посылки."""
    id: int
    name: str
    weight: Decimal
    type_id: int
    value_usd: Decimal
    session_id: str
    delivery_price_rub: Optional[Decimal] = Field(default=None)
    created_at: Optional[datetime] = Field(default=None)
    updated_at: Optional[datetime] = Field(default=None)
    type_name: Optional[str] = Field(default=None)

    @computed_field  # type: ignore[misc]
    @property
    def has_calculated_price(self) -> bool:
        return self.delivery_price_rub is not None

    @computed_field  # type: ignore[misc]
    @property
    def status(self) -> str:
        return "calculated" if self.has_calculated_price else "pending"


class PackageListItemDTO(BaseModel):
    """Элемент списка посылок."""
    id: int
    name: str
    weight: Decimal
    type_id: int
    type_name: str
    value_usd: Decimal
    delivery_price_rub: Optional[Decimal] = Field(default=None)
    status: str
    created_at: Optional[datetime] = Field(default=None)


class PackageFilterDTO(BaseModel):
    """Фильтры поиска посылок."""
    session_id: str
    type_id: Optional[int] = Field(default=None)
    has_price: Optional[bool] = Field(default=None)
    offset: int = Field(default=0)
    limit: int = Field(default=100)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\contracts\pagination.py --------------------
"""
Контракты UC для пагинации (Pydantic v2).
"""
from typing import Generic, TypeVar, List
from pydantic import BaseModel, computed_field

T = TypeVar('T')


class PageRequest(BaseModel):
    """Запрос страницы."""
    page: int = 1
    size: int = 20

    @computed_field  # type: ignore[misc]
    @property
    def offset(self) -> int:
        return (self.page - 1) * self.size

    @computed_field  # type: ignore[misc]
    @property
    def limit(self) -> int:
        return self.size


class PageResponse(BaseModel, Generic[T]):
    """Ответ со страницей результатов."""
    items: List[T]
    total: int
    page: int
    size: int

    @computed_field  # type: ignore[misc]
    @property
    def total_pages(self) -> int:
        return (self.total + self.size - 1) // self.size

    @computed_field  # type: ignore[misc]
    @property
    def has_next(self) -> bool:
        return self.page < self.total_pages

    @computed_field  # type: ignore[misc]
    @property
    def has_prev(self) -> bool:
        return self.page > 1


class PaginationDTO(BaseModel, Generic[T]):
    """Пагинация для UC."""
    items: List[T]
    total: int
    page: int
    pages: int
    size: int
    has_next: bool
    has_prev: bool
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\contracts\__init__.py --------------------
# Контракты слоя приложения (Pydantic модели для UC)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\use_cases\get_packages.py --------------------
"""
Use Case: Получение списка посылок пользователя.
"""
from application.contracts.package_dto import PackageListItemDTO, PackageFilterDTO
from application.contracts.pagination import PaginationDTO
from domain.ports.package_repository import PackageRepository
from domain.ports.package_type_repository import PackageTypeRepository
from domain.value_objects.identifiers import SessionId
from core.exceptions import ValidationError


class GetPackagesUseCase:
    """Use Case для получения списка посылок пользователя."""
    
    def __init__(
        self,
        package_repository: PackageRepository,
        package_type_repository: PackageTypeRepository
    ):
        self.package_repository = package_repository
        self.package_type_repository = package_type_repository
    
    async def execute(self, filters: PackageFilterDTO) -> PaginationDTO[PackageListItemDTO]:
        """
        Получить список посылок с фильтрами и пагинацией.
        
        Args:
            filters: Фильтры для поиска
            
        Returns:
            Пагинированный список посылок
        """
        # Валидация входных данных
        await self._validate_filters(filters)
        
        # Получаем session_id
        session_id = SessionId.from_string(filters.session_id)
        
        # Получаем общее количество
        total_count = await self.package_repository.count_by_session_id(
            session_id=session_id,
            type_id=filters.type_id,
            has_price=filters.has_price
        )
        
        # Получаем посылки для текущей страницы
        packages = await self.package_repository.get_by_session_id(
            session_id=session_id,
            type_id=filters.type_id,
            has_price=filters.has_price,
            offset=filters.offset,
            limit=filters.limit
        )
        
        # Получаем типы посылок для маппинга
        package_types = await self.package_type_repository.get_all()
        type_mapping = {t.id: t for t in package_types}
        
        # Конвертируем в DTO
        items = []
        for package in packages:
            package_type = type_mapping.get(package.type_id)
            type_name = package_type.display_name if package_type else "Неизвестный"
            
            items.append(PackageListItemDTO(
                id=package.id.value,
                name=package.name,
                weight=package.weight,
                type_id=package.type_id,
                type_name=type_name,
                value_usd=package.value_usd,
                delivery_price_rub=package.delivery_price_rub,
                status=package.get_display_status(),
                created_at=package.created_at
            ))
        
        # Создаем пагинацию
        page_size = filters.limit
        current_page = (filters.offset // page_size) + 1
        total_pages = (total_count + page_size - 1) // page_size
        
        return PaginationDTO(
            items=items,
            total=total_count,
            page=current_page,
            pages=total_pages,
            size=page_size,
            has_next=current_page < total_pages,
            has_prev=current_page > 1
        )
    
    async def _validate_filters(self, filters: PackageFilterDTO) -> None:
        """Валидировать фильтры."""
        if filters.limit <= 0:
            raise ValidationError("Лимит должен быть больше нуля", "limit")
        
        if filters.limit > 100:
            raise ValidationError("Лимит не должен превышать 100", "limit")
        
        if filters.offset < 0:
            raise ValidationError("Смещение не может быть отрицательным", "offset")
        
        if filters.type_id is not None:
            if filters.type_id <= 0 or filters.type_id > 3:
                raise ValidationError("Неверный тип посылки", "type_id")
        
        # Валидация session_id
        try:
            SessionId.from_string(filters.session_id)
        except ValueError as e:
            raise ValidationError(f"Неверный session_id: {str(e)}", "session_id")
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\use_cases\get_package_details.py --------------------
"""
Use Case: Получение деталей посылки.
"""
from application.contracts.package_dto import PackageDTO
from domain.ports.package_repository import PackageRepository
from domain.ports.package_type_repository import PackageTypeRepository
from domain.value_objects.identifiers import PackageId, SessionId
from core.exceptions import NotFoundError, ValidationError


class GetPackageDetailsUseCase:
    """Use Case для получения деталей посылки."""
    
    def __init__(
        self,
        package_repository: PackageRepository,
        package_type_repository: PackageTypeRepository
    ):
        self.package_repository = package_repository
        self.package_type_repository = package_type_repository
    
    async def execute(self, package_id: int, session_id: str) -> PackageDTO:
        """
        Получить детали посылки по ID.
        
        Args:
            package_id: ID посылки
            session_id: ID сессии пользователя
            
        Returns:
            DTO с деталями посылки
            
        Raises:
            NotFoundError: Если посылка не найдена
            ValidationError: Если данные невалидны
        """
        # Валидация входных данных
        await self._validate_input(package_id, session_id)
        
        # Получаем посылку
        domain_package_id = PackageId.from_int(package_id)
        package = await self.package_repository.get_by_id(domain_package_id)
        
        if not package:
            raise NotFoundError("Посылка", str(package_id))
        
        # Проверяем принадлежность посылки пользователю
        if package.session_id != session_id:
            raise NotFoundError("Посылка", str(package_id))
        
        # Получаем тип посылки для отображения
        package_type = await self.package_type_repository.get_by_id(package.type_id)
        
        # Конвертируем в DTO
        package_dto = PackageDTO(
            id=package.id.value,
            name=package.name,
            weight=package.weight,
            type_id=package.type_id,
            value_usd=package.value_usd,
            session_id=package.session_id,
            delivery_price_rub=package.delivery_price_rub,
            created_at=package.created_at,
            updated_at=package.updated_at
        )
        
        # Добавляем информацию о типе
        if package_type:
            package_dto.type_name = package_type.display_name
        
        return package_dto
    
    async def _validate_input(self, package_id: int, session_id: str) -> None:
        """Валидировать входные данные."""
        if package_id <= 0:
            raise ValidationError("ID посылки должен быть больше нуля", "package_id")
        
        # Валидация session_id
        try:
            SessionId.from_string(session_id)
        except ValueError as e:
            raise ValidationError(f"Неверный session_id: {str(e)}", "session_id")
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\use_cases\get_package_types.py --------------------
"""
Use Case: Получение всех типов посылок.
"""
from typing import List
from domain.ports.package_type_repository import PackageTypeRepository
from domain.entities.package_type import PackageType


class GetPackageTypesUseCase:
    """Use Case для получения всех типов посылок."""
    
    def __init__(self, package_type_repository: PackageTypeRepository):
        self.package_type_repository = package_type_repository
    
    async def execute(self) -> List[PackageType]:
        """
        Получить все доступные типы посылок.
        
        Returns:
            Список типов посылок
        """
        return await self.package_type_repository.get_all()
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\use_cases\register_package.py --------------------
"""
Use Case: Регистрация посылки.
UC: валидация входа, вызов repo.save, возврат ID для сессии.
"""
from application.contracts.package_dto import CreatePackageDTO, PackageDTO
from domain.entities.package import Package
from domain.ports.package_repository import PackageRepository
from domain.ports.package_type_repository import PackageTypeRepository
from domain.value_objects.identifiers import PackageId, SessionId
from core.exceptions import ValidationError, NotFoundError


class RegisterPackageUseCase:
    """Use Case для регистрации новой посылки."""
    
    def __init__(
        self,
        package_repository: PackageRepository,
        package_type_repository: PackageTypeRepository
    ):
        self.package_repository = package_repository
        self.package_type_repository = package_type_repository
    
    async def execute(self, dto: CreatePackageDTO) -> PackageDTO:
        """
        Зарегистрировать новую посылку.
        
        Args:
            dto: Данные для создания посылки
            
        Returns:
            DTO созданной посылки
            
        Raises:
            ValidationError: Если данные невалидны
            NotFoundError: Если тип посылки не найден
        """
        # Валидация входных данных
        await self._validate_input(dto)
        
        # Проверяем, что тип посылки существует
        if not await self.package_type_repository.exists(dto.type_id):
            raise NotFoundError("Тип посылки", str(dto.type_id))
        
        # Создаем доменную сущность
        package = Package(
            id=PackageId.from_int(0),  # ID будет присвоен при сохранении
            name=dto.name.strip(),
            weight=dto.weight,
            type_id=dto.type_id,
            value_usd=dto.value_usd,
            session_id=dto.session_id
        )
        
        # Сохраняем в репозитории
        saved_package = await self.package_repository.save(package)
        
        # Возвращаем DTO
        return self._to_dto(saved_package)
    
    async def _validate_input(self, dto: CreatePackageDTO) -> None:
        """Валидировать входные данные."""
        if not dto.name or not dto.name.strip():
            raise ValidationError("Название посылки не может быть пустым", "name")
        
        if dto.weight <= 0:
            raise ValidationError("Вес посылки должен быть больше нуля", "weight")
        
        if dto.value_usd < 0:
            raise ValidationError("Стоимость посылки не может быть отрицательной", "value_usd")
        
        if dto.type_id <= 0:
            raise ValidationError("Неверный тип посылки", "type_id")
        
        # Валидация session_id
        try:
            SessionId.from_string(dto.session_id)
        except ValueError as e:
            raise ValidationError(f"Неверный session_id: {str(e)}", "session_id")
    
    def _to_dto(self, package: Package) -> PackageDTO:
        """Конвертировать доменную сущность в DTO."""
        return PackageDTO(
            id=package.id.value,
            name=package.name,
            weight=package.weight,
            type_id=package.type_id,
            value_usd=package.value_usd,
            session_id=package.session_id,
            delivery_price_rub=package.delivery_price_rub,
            created_at=package.created_at,
            updated_at=package.updated_at
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\application\use_cases\__init__.py --------------------
# Use Cases - варианты использования
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\bootstrap\asgi.py --------------------
"""
ASGI-приложение для prod/uvicorn/gunicorn.
"""
from presentation.fastapi import create_app

# Создание приложения для ASGI серверов
app = create_app()

.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\bootstrap\main.py --------------------
"""
Точка входа приложения (uvicorn).
Инициализация DI, FastAPI, роутов, middleware.
"""
import uvicorn
from core.config import get_settings
from infrastructure.logging.config import setup_logging
from presentation.fastapi import create_app


def main() -> None:
    """Основная функция запуска приложения."""
    settings = get_settings()
    
    # Настройка логирования
    setup_logging(settings.DEBUG)
    

    # Запуск сервера
    uvicorn.run(
        "bootstrap.asgi:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        access_log=True,
        log_config=None,  # Используем наше собственное логирование
    )


if __name__ == "__main__":
    main()
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\bootstrap\__init__.py --------------------
# Bootstrap модуль - точка входа приложения
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\core\config.py --------------------
# core/config.py
"""
Конфигурация приложения с использованием Pydantic Settings (v2).
Добавлены свойства для ASYNC/SYNC URL базы.
"""

from functools import lru_cache
from typing import List, Optional

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # === Основные ===
    APP_NAME: str = "Delivery App"
    DEBUG: bool = False
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # === База данных ===
    POSTGRES_USER: str = "postgres"
    POSTGRES_PASSWORD: str = "password"
    POSTGRES_HOST: str = "localhost"
    POSTGRES_PORT: int = 5432
    POSTGRES_DB: str = "delivery_app"

    @property
    def SYNC_DATABASE_URL(self) -> str:
        """
        Синхронный DSN (если когда-то понадобится). НЕ используется приложением/миграциями.
        """
        return (
            f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}"
            f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
        )

    @property
    def ASYNC_DATABASE_URL(self) -> str:
        """
        Асинхронный DSN (используется приложением и alembic env.py).
        """
        # допускаем, что хост/порт/логин уже могут быть переопределены через переменные окружения
        # возвращаем URL на asyncpg:
        return self.SYNC_DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

    # === Celery (RabbitMQ + RPC backend) ===
    CELERY_BROKER_URL: str = "amqp://guest:guest@rabbitmq:5672//"
    CELERY_RESULT_BACKEND: str = "rpc://"

    # === CBR API ===
    CBR_API_URL: str = "https://www.cbr-xml-daily.ru/daily_json.js"
    CBR_TIMEOUT: int = 10
    CBR_RETRY_COUNT: int = 3

    # === Redis ===
    REDIS_URL: str | None = None  # пример: redis://redis:6379/0
    REDIS_DB_CACHE: int = 0
    REDIS_DB_SESSIONS: int = 1

    # === CORS ===
    # В .env хранится JSON-массив строк -> pydantic корректно распарсит
    # В продакшене ограничьте список доменов фронтенда
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://127.0.0.1:3000"]

    # === Security ===
    SESSION_SECRET_KEY: str = "your-secret-key-change-in-production"
    SESSION_COOKIE_NAME: str = "delivery_session"
    SESSION_COOKIE_MAX_AGE: int = 86400 * 30  # 30 дней
    # Для продакшена рекомендуется True (HTTPS); в dev может быть False
    SESSION_COOKIE_SECURE: bool = False  # True для HTTPS
    SESSION_COOKIE_HTTPONLY: bool = True
    SESSION_COOKIE_SAMESITE: str = "lax"

    # === Документация ===
    DOCS_URL: Optional[str] = "/docs"
    REDOC_URL: Optional[str] = "/redoc"
    OPENAPI_URL: Optional[str] = "/openapi.json"

    # Pydantic v2 Settings config
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=True,
        extra="ignore",  # игнорируем лишние переменные окружения (например, REDIS_*)
    )


@lru_cache()
def get_settings() -> Settings:
    """Получить настройки приложения (с кэшированием)."""
    return Settings()
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\core\exceptions.py --------------------
"""
Базовые исключения приложения.
Кастомные ошибки для доменной логики и API.
"""
from typing import Any, Dict, Optional


class AppError(Exception):
    """Базовое исключение приложения."""
    
    def __init__(
        self,
        message: str,
        error_code: str = "APP_ERROR",
        details: Optional[Dict[str, Any]] = None,
    ):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)


class ValidationError(AppError):
    """Ошибка валидации данных."""
    
    def __init__(
        self,
        message: str = "Ошибка валидации данных",
        field: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=message,
            error_code="VALIDATION_ERROR",
            details=details or {}
        )
        if field:
            self.details["field"] = field


class NotFoundError(AppError):
    """Ошибка - ресурс не найден."""
    
    def __init__(
        self,
        resource: str = "Ресурс",
        resource_id: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        message = f"{resource} не найден"
        if resource_id:
            message += f" (ID: {resource_id})"
        
        super().__init__(
            message=message,
            error_code="NOT_FOUND",
            details=details or {}
        )
        if resource_id:
            self.details["resource_id"] = resource_id


class RateLimitError(AppError):
    """Ошибка превышения лимита запросов."""
    
    def __init__(
        self,
        message: str = "Превышен лимит запросов",
        retry_after: Optional[int] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=message,
            error_code="RATE_LIMIT",
            details=details or {}
        )
        if retry_after:
            self.details["retry_after"] = retry_after


class ExternalServiceError(AppError):
    """Ошибка внешнего сервиса."""
    
    def __init__(
        self,
        service_name: str,
        message: str = "Ошибка внешнего сервиса",
        status_code: Optional[int] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=f"{service_name}: {message}",
            error_code="EXTERNAL_SERVICE_ERROR",
            details=details or {}
        )
        self.details["service_name"] = service_name
        if status_code:
            self.details["status_code"] = status_code


class DatabaseError(AppError):
    """Ошибка базы данных."""
    
    def __init__(
        self,
        message: str = "Ошибка базы данных",
        operation: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=message,
            error_code="DATABASE_ERROR",
            details=details or {}
        )
        if operation:
            self.details["operation"] = operation


class CacheError(AppError):
    """Ошибка кэша."""
    
    def __init__(
        self,
        message: str = "Ошибка кэша",
        cache_key: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=message,
            error_code="CACHE_ERROR",
            details=details or {}
        )
        if cache_key:
            self.details["cache_key"] = cache_key


class BusinessLogicError(AppError):
    """Ошибка бизнес-логики."""
    
    def __init__(
        self,
        message: str,
        rule: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(
            message=message,
            error_code="BUSINESS_LOGIC_ERROR",
            details=details or {}
        )
        if rule:
            self.details["rule"] = rule
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\core\__init__.py --------------------
# Core модуль - техническое ядро
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\docker\app.Dockerfile --------------------
FROM python:3.12-slim

# Установка системных зависимостей
RUN set -eux; \
        apt-get -o Acquire::Retries=3 update; \
        for i in 1 2 3; do \
            apt-get install -y --no-install-recommends gcc && break || (echo "Retrying apt install ($i)..." && sleep 5); \
        done; \
        rm -rf /var/lib/apt/lists/*

# Создание пользователя для приложения
RUN groupadd -r app && useradd -r -g app app

# Установка рабочей директории
WORKDIR /app

# Копирование файлов зависимостей
COPY pyproject.toml poetry.lock* ./

# Установка Poetry
RUN pip install poetry

# Конфигурация Poetry
RUN poetry config virtualenvs.create false

# Установка зависимостей
RUN poetry install --only main --no-interaction --no-ansi --no-root


# Копирование кода приложения
COPY . .

# Изменение владельца файлов
RUN chown -R app:app /app

# Переключение на пользователя приложения
USER app

# Команда по умолчанию
CMD ["python", "-m", "bootstrap.main"]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\__init__.py --------------------
# Domain модуль - чистая модель предметной области
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\entities\package.py --------------------
"""
Доменная сущность: Посылка.
Entity: Package(id, name, weight, type_id, value_usd, delivery_price_rub).
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import Optional
from datetime import datetime

from domain.value_objects.identifiers import PackageId


@dataclass
class Package:
    """Доменная сущность посылки."""
    
    id: PackageId
    name: str
    weight: Decimal  # в килограммах
    type_id: int
    value_usd: Decimal  # стоимость в долларах
    session_id: str
    delivery_price_rub: Optional[Decimal] = None  # цена доставки в рублях
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Валидация данных после создания."""
        if self.weight <= 0:
            raise ValueError("Вес посылки должен быть больше нуля")
        
        if self.value_usd < 0:
            raise ValueError("Стоимость посылки не может быть отрицательной")
        
        if self.name.strip() == "":
            raise ValueError("Название посылки не может быть пустым")
    
    @property
    def has_calculated_price(self) -> bool:
        """Проверить, рассчитана ли цена доставки."""
        return self.delivery_price_rub is not None
    
    @property
    def weight_kg(self) -> float:
        """Получить вес в килограммах как float."""
        return float(self.weight)
    
    @property
    def value_usd_float(self) -> float:
        """Получить стоимость в долларах как float."""
        return float(self.value_usd)
    
    def set_delivery_price(self, price_rub: Decimal) -> None:
        """Установить цену доставки."""
        if price_rub < 0:
            raise ValueError("Цена доставки не может быть отрицательной")
        self.delivery_price_rub = price_rub
    
    def get_display_status(self) -> str:
        """Получить статус для отображения."""
        if self.has_calculated_price:
            return "calculated"
        return "pending"
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\entities\package_type.py --------------------
"""
Доменная сущность: Тип посылки.
Entity: PackageType(id, name=[clothes,electronics,other]).
"""
from dataclasses import dataclass
from typing import ClassVar


@dataclass(frozen=True)
class PackageType:
    """Доменная сущность типа посылки."""
    
    id: int
    name: str
    
    # Константы типов
    CLOTHES: ClassVar[str] = "clothes"
    ELECTRONICS: ClassVar[str] = "electronics"
    OTHER: ClassVar[str] = "other"
    
    # Мапинг ID -> название
    TYPE_MAPPING: ClassVar[dict[int, str]] = {
        1: CLOTHES,
        2: ELECTRONICS,
        3: OTHER,
    }
    
    # Обратный мапинг название -> ID
    NAME_TO_ID_MAPPING: ClassVar[dict[str, int]] = {
        CLOTHES: 1,
        ELECTRONICS: 2,
        OTHER: 3,
    }
    
    def __post_init__(self):
        """Валидация данных после создания."""
        if self.id not in self.TYPE_MAPPING:
            raise ValueError(f"Недопустимый ID типа посылки: {self.id}")
        
        if self.name not in self.NAME_TO_ID_MAPPING:
            raise ValueError(f"Недопустимое название типа посылки: {self.name}")
        
        if self.TYPE_MAPPING[self.id] != self.name:
            raise ValueError(f"Несоответствие ID {self.id} и названия {self.name}")
    
    @classmethod
    def get_all_types(cls) -> list["PackageType"]:
        """Получить все доступные типы посылок."""
        return [
            cls(id=type_id, name=type_name)
            for type_id, type_name in cls.TYPE_MAPPING.items()
        ]
    
    @classmethod
    def get_by_id(cls, type_id: int) -> "PackageType":
        """Получить тип посылки по ID."""
        if type_id not in cls.TYPE_MAPPING:
            raise ValueError(f"Тип посылки с ID {type_id} не найден")
        return cls(id=type_id, name=cls.TYPE_MAPPING[type_id])
    
    @classmethod
    def get_by_name(cls, name: str) -> "PackageType":
        """Получить тип посылки по названию."""
        if name not in cls.NAME_TO_ID_MAPPING:
            raise ValueError(f"Тип посылки с названием {name} не найден")
        return cls(id=cls.NAME_TO_ID_MAPPING[name], name=name)
    
    @property
    def display_name(self) -> str:
        """Получить человекочитаемое название."""
        display_names = {
            self.CLOTHES: "Одежда",
            self.ELECTRONICS: "Электроника", 
            self.OTHER: "Другое",
        }
        return display_names.get(self.name, self.name)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\entities\__init__.py --------------------
# Entities - доменные сущности
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\ports\currency_rates_provider.py --------------------
"""
Абстрактный интерфейс для получения курсов валют.
Порт получения курса USD→RUB (снаружи: CBR + кэш).
"""
from abc import ABC, abstractmethod
from typing import Optional

from domain.value_objects.currency import Rate, Currency


class CurrencyRatesProvider(ABC):
    """Абстрактный провайдер курсов валют."""
    
    @abstractmethod
    async def get_usd_to_rub_rate(self) -> Optional[Rate]:
        """
        Получить текущий курс USD -> RUB.
        
        Returns:
            Курс USD -> RUB или None, если не удалось получить
        """
        pass
    
    @abstractmethod
    async def get_rate(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> Optional[Rate]:
        """
        Получить курс между двумя валютами.
        
        Args:
            from_currency: Исходная валюта
            to_currency: Целевая валюта
            
        Returns:
            Курс валют или None, если не удалось получить
        """
        pass
    
    @abstractmethod
    async def is_rate_available(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> bool:
        """
        Проверить, доступен ли курс между валютами.
        
        Args:
            from_currency: Исходная валюта
            to_currency: Целевая валюта
            
        Returns:
            True, если курс доступен, False иначе
        """
        pass
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\ports\package_repository.py --------------------
"""
Абстрактный интерфейс для работы с посылками.
Сохранить/получить/листинг с пагинацией и фильтрами.
"""
from abc import ABC, abstractmethod
from typing import Optional

from domain.entities.package import Package
from domain.value_objects.identifiers import PackageId, SessionId


class PackageRepository(ABC):
    """Абстрактный репозиторий для работы с посылками."""
    
    @abstractmethod
    async def save(self, package: Package) -> Package:
        """
        Сохранить посылку.
        
        Args:
            package: Посылка для сохранения
            
        Returns:
            Сохранённая посылка с ID
        """
        pass
    
    @abstractmethod
    async def get_by_id(self, package_id: PackageId) -> Optional[Package]:
        """
        Получить посылку по ID.
        
        Args:
            package_id: ID посылки
            
        Returns:
            Посылка или None, если не найдена
        """
        pass
    
    @abstractmethod
    async def get_by_session_id(
        self,
        session_id: SessionId,
        type_id: Optional[int] = None,
        has_price: Optional[bool] = None,
        offset: int = 0,
        limit: int = 100
    ) -> list[Package]:
        """
        Получить посылки по session_id с фильтрами и пагинацией.
        
        Args:
            session_id: ID сессии
            type_id: Фильтр по типу посылки (опционально)
            has_price: Фильтр по наличию рассчитанной цены (опционально)
            offset: Смещение для пагинации
            limit: Лимит записей
            
        Returns:
            Список посылок
        """
        pass
    
    @abstractmethod
    async def count_by_session_id(
        self,
        session_id: SessionId,
        type_id: Optional[int] = None,
        has_price: Optional[bool] = None
    ) -> int:
        """
        Подсчитать количество посылок по session_id с фильтрами.
        
        Args:
            session_id: ID сессии
            type_id: Фильтр по типу посылки (опционально)
            has_price: Фильтр по наличию рассчитанной цены (опционально)
            
        Returns:
            Количество посылок
        """
        pass
    
    @abstractmethod
    async def get_packages_without_price(
        self,
        limit: int = 100
    ) -> list[Package]:
        """
        Получить посылки без рассчитанной цены доставки.
        
        Args:
            limit: Максимальное количество записей
            
        Returns:
            Список посылок без цены
        """
        pass
    
    @abstractmethod
    async def update_delivery_prices(
        self,
        package_prices: dict[int, float]
    ) -> int:
        """
        Массово обновить цены доставки для посылок.
        
        Args:
            package_prices: Словарь {package_id: delivery_price_rub}
            
        Returns:
            Количество обновлённых записей
        """
        pass
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\ports\package_type_repository.py --------------------
"""
Абстрактный интерфейс для работы с типами посылок.
CRUD операции для типов посылок.
"""
from abc import ABC, abstractmethod
from typing import Optional

from domain.entities.package_type import PackageType


class PackageTypeRepository(ABC):
    """Абстрактный репозиторий для работы с типами посылок."""
    
    @abstractmethod
    async def get_all(self) -> list[PackageType]:
        """
        Получить все типы посылок.
        
        Returns:
            Список всех типов посылок
        """
        pass
    
    @abstractmethod
    async def get_by_id(self, type_id: int) -> Optional[PackageType]:
        """
        Получить тип посылки по ID.
        
        Args:
            type_id: ID типа посылки
            
        Returns:
            Тип посылки или None, если не найден
        """
        pass
    
    @abstractmethod
    async def get_by_name(self, name: str) -> Optional[PackageType]:
        """
        Получить тип посылки по названию.
        
        Args:
            name: Название типа посылки
            
        Returns:
            Тип посылки или None, если не найден
        """
        pass
    
    @abstractmethod
    async def exists(self, type_id: int) -> bool:
        """
        Проверить, существует ли тип посылки.
        
        Args:
            type_id: ID типа посылки
            
        Returns:
            True, если тип существует, False иначе
        """
        pass
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\ports\session_repository.py --------------------
"""
Абстрактный интерфейс для работы с сессиями.
Связка session_id ↔ данные (если понадобится дополнительное хранение).
"""
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any

from domain.value_objects.identifiers import SessionId


class SessionRepository(ABC):
    """Абстрактный репозиторий для работы с сессиями."""
    
    @abstractmethod
    async def get_session_data(
        self, 
        session_id: SessionId
    ) -> Optional[Dict[str, Any]]:
        """
        Получить данные сессии.
        
        Args:
            session_id: ID сессии
            
        Returns:
            Данные сессии или None, если сессия не найдена
        """
        pass
    
    @abstractmethod
    async def save_session_data(
        self,
        session_id: SessionId,
        data: Dict[str, Any],
        ttl: Optional[int] = None
    ) -> None:
        """
        Сохранить данные сессии.
        
        Args:
            session_id: ID сессии
            data: Данные для сохранения
            ttl: Время жизни в секундах (опционально)
        """
        pass
    
    @abstractmethod
    async def delete_session(self, session_id: SessionId) -> None:
        """
        Удалить сессию.
        
        Args:
            session_id: ID сессии
        """
        pass
    
    @abstractmethod
    async def session_exists(self, session_id: SessionId) -> bool:
        """
        Проверить, существует ли сессия.
        
        Args:
            session_id: ID сессии
            
        Returns:
            True, если сессия существует, False иначе
        """
        pass
    
    @abstractmethod
    async def extend_session_ttl(
        self,
        session_id: SessionId,
        ttl: int
    ) -> None:
        """
        Продлить время жизни сессии.
        
        Args:
            session_id: ID сессии
            ttl: Новое время жизни в секундах
        """
        pass
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\ports\__init__.py --------------------
# Ports - абстрактные интерфейсы
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\services\delivery_pricing.py --------------------
"""
Доменный сервис для расчёта стоимости доставки.
Правила расчёта: (kg*0.5 + usd*0.01) * usd_to_rub.
"""
from decimal import Decimal

from domain.entities.package import Package
from domain.value_objects.currency import Rate


class DeliveryPricingService:
    """Доменный сервис для расчёта стоимости доставки."""
    
    # Коэффициенты для расчёта
    WEIGHT_COEFFICIENT = Decimal("0.5")  # 0.5 USD за кг
    VALUE_COEFFICIENT = Decimal("0.01")  # 1% от стоимости
    
    def calculate_delivery_price(
        self, 
        package: Package, 
        usd_to_rub_rate: Rate
    ) -> Decimal:
        """
        Рассчитать стоимость доставки посылки.
        
        Формула: (вес_кг * 0.5 + стоимость_usd * 0.01) * курс_USD_RUB
        
        Args:
            package: Посылка для расчёта
            usd_to_rub_rate: Курс USD -> RUB
            
        Returns:
            Стоимость доставки в рублях
        """
        # Базовая стоимость в USD
        weight_cost_usd = package.weight * self.WEIGHT_COEFFICIENT
        value_cost_usd = package.value_usd * self.VALUE_COEFFICIENT
        
        total_cost_usd = weight_cost_usd + value_cost_usd
        
        # Конвертация в рубли
        total_cost_rub = usd_to_rub_rate.convert(total_cost_usd)
        
        # Округляем до 2 знаков после запятой
        return total_cost_rub.quantize(Decimal("0.01"))
    
    def calculate_delivery_prices_bulk(
        self,
        packages: list[Package],
        usd_to_rub_rate: Rate
    ) -> dict[int, Decimal]:
        """
        Рассчитать стоимость доставки для множества посылок.
        
        Args:
            packages: Список посылок
            usd_to_rub_rate: Курс USD -> RUB
            
        Returns:
            Словарь {package_id: delivery_price_rub}
        """
        results = {}
        
        for package in packages:
            try:
                price = self.calculate_delivery_price(package, usd_to_rub_rate)
                results[package.id.value] = price
            except Exception:
                # В случае ошибки пропускаем пакет
                # Логирование должно быть на уровне приложения
                continue
        
        return results
    
    def validate_calculation_inputs(
        self, 
        package: Package, 
        rate: Rate
    ) -> None:
        """
        Валидировать входные данные для расчёта.
        
        Args:
            package: Посылка
            rate: Курс валют
            
        Raises:
            ValueError: Если данные невалидны
        """
        if package.weight <= 0:
            raise ValueError("Вес посылки должен быть больше нуля")
        
        if package.value_usd < 0:
            raise ValueError("Стоимость посылки не может быть отрицательной")
        
        if rate.value <= 0:
            raise ValueError("Курс валют должен быть больше нуля")
        
        # Проверяем, что курс USD -> RUB
        if rate.from_currency.code != "USD" or rate.to_currency.code != "RUB":
            raise ValueError("Поддерживается только курс USD -> RUB")
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\services\__init__.py --------------------
# Services - доменные сервисы
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\value_objects\currency.py --------------------
"""
Value Objects для валют и курсов.
VO: Currency(code="USD"/"RUB"), Rate(value: Decimal).
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import ClassVar
from datetime import datetime


@dataclass(frozen=True)
class Currency:
    """Value Object для валюты."""
    
    code: str
    
    # Поддерживаемые валюты
    USD: ClassVar[str] = "USD"
    RUB: ClassVar[str] = "RUB"
    
    SUPPORTED_CURRENCIES: ClassVar[set[str]] = {USD, RUB}
    
    def __post_init__(self):
        """Валидация кода валюты."""
        if self.code not in self.SUPPORTED_CURRENCIES:
            raise ValueError(f"Неподдерживаемая валюта: {self.code}")
    
    @classmethod
    def usd(cls) -> "Currency":
        """Создать USD валюту."""
        return cls(code=cls.USD)
    
    @classmethod
    def rub(cls) -> "Currency":
        """Создать RUB валюту."""
        return cls(code=cls.RUB)


@dataclass(frozen=True)
class Rate:
    """Value Object для курса валют."""
    
    value: Decimal
    from_currency: Currency
    to_currency: Currency
    # Время, на которое актуален курс (по данным провайдера)
    updated_at: datetime | None = None
    
    def __post_init__(self):
        """Валидация курса."""
        if self.value <= 0:
            raise ValueError("Курс валют должен быть больше нуля")
        
        if self.from_currency.code == self.to_currency.code:
            raise ValueError("Валюты должны быть разными")
    
    @classmethod
    def usd_to_rub(cls, rate_value: Decimal, updated_at: datetime | None = None) -> "Rate":
        """Создать курс USD -> RUB."""
        return cls(
            value=rate_value,
            from_currency=Currency.usd(),
            to_currency=Currency.rub(),
            updated_at=updated_at,
        )
    
    def convert(self, amount: Decimal) -> Decimal:
        """Конвертировать сумму по курсу."""
        if amount < 0:
            raise ValueError("Сумма не может быть отрицательной")
        return amount * self.value
    
    @property
    def rate_float(self) -> float:
        """Получить курс как float."""
        return float(self.value)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\value_objects\identifiers.py --------------------
"""
Value Objects для идентификаторов.
VO: PackageId, SessionId (примитивы-обёртки).
"""
from dataclasses import dataclass
from typing import Union
import uuid


@dataclass(frozen=True)
class PackageId:
    """Value Object для ID посылки."""
    
    value: int
    
    def __post_init__(self):
        """Валидация ID."""
        if not isinstance(self.value, int):
            raise TypeError("Package ID должен быть целым числом")
        
        # Разрешаем 0 как временное значение для новых сущностей (до сохранения в БД)
        if self.value < 0:
            raise ValueError("Package ID не может быть отрицательным")
    
    def __str__(self) -> str:
        return str(self.value)
    
    def __int__(self) -> int:
        return self.value
    
    @classmethod
    def from_int(cls, value: int) -> "PackageId":
        """Создать PackageId из целого числа."""
        return cls(value=value)


@dataclass(frozen=True)
class SessionId:
    """Value Object для ID сессии."""
    
    value: str
    
    def __post_init__(self):
        """Валидация ID сессии."""
        if not isinstance(self.value, str):
            raise TypeError("Session ID должен быть строкой")
        
        if not self.value.strip():
            raise ValueError("Session ID не может быть пустым")
        
        # Проверяем, что это валидный UUID
        try:
            uuid.UUID(self.value)
        except ValueError:
            raise ValueError("Session ID должен быть валидным UUID")
    
    def __str__(self) -> str:
        return self.value
    
    @classmethod
    def from_string(cls, value: str) -> "SessionId":
        """Создать SessionId из строки."""
        return cls(value=value)
    
    @classmethod
    def generate(cls) -> "SessionId":
        """Сгенерировать новый SessionId."""
        return cls(value=str(uuid.uuid4()))
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\domain\value_objects\__init__.py --------------------
# Value Objects - объекты-значения
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\__init__.py --------------------
# Infrastructure модуль - реализации портов
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\database\init_db.py --------------------
"""
Скрипт инициализации базы данных.
Заполняет таблицу package_types тремя типами посылок если они отсутствуют.
"""
import asyncio
import sys
from pathlib import Path

# Добавляем корневую папку проекта в sys.path
sys.path.append(str(Path(__file__).parent.parent.parent))

from sqlalchemy import select, text
from sqlalchemy.dialects.postgresql import insert

from infrastructure.sqlalchemy.database import AsyncSessionLocal
from domain.entities.package_type import PackageType
from infrastructure.sqlalchemy.models import PackageTypeModel


async def init_package_types():
    """Инициализировать типы посылок в базе данных."""
    
    # Получаем все доменные типы
    domain_types = PackageType.get_all_types()
    
    async with AsyncSessionLocal() as session:
        try:
            print("🔄 Проверяем существующие типы посылок...")
            
            # Проверяем, какие типы уже есть в БД
            existing_types_result = await session.execute(
                select(PackageTypeModel.id, PackageTypeModel.name)
            )
            existing_types = {row.id: row.name for row in existing_types_result}
            
            print(f"📋 Найдено существующих типов: {len(existing_types)}")
            for type_id, type_name in existing_types.items():
                print(f"   - {type_id}: {type_name}")
            
            # Вставляем отсутствующие типы
            types_to_insert = []
            for domain_type in domain_types:
                if domain_type.id not in existing_types:
                    types_to_insert.append({
                        'id': domain_type.id,
                        'name': domain_type.name
                    })
                    print(f"➕ Будет добавлен тип: {domain_type.id} - {domain_type.name}")
                else:
                    print(f"✅ Тип уже существует: {domain_type.id} - {domain_type.name}")
            
            if types_to_insert:
                # Используем PostgreSQL UPSERT (ON CONFLICT DO NOTHING)
                stmt = insert(PackageTypeModel).values(types_to_insert)
                stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
                
                await session.execute(stmt)
                await session.commit()
                
                print(f"✅ Успешно добавлено {len(types_to_insert)} типов посылок")
            else:
                print("✅ Все типы посылок уже существуют в базе данных")
            
            # Проверяем финальное состояние
            final_result = await session.execute(
                select(PackageTypeModel.id, PackageTypeModel.name)
                .order_by(PackageTypeModel.id)
            )
            final_types = list(final_result)
            
            print(f"\n📊 Итоговое состояние типов посылок ({len(final_types)}):")
            for row in final_types:
                print(f"   - {row.id}: {row.name}")
                
        except Exception as e:
            print(f"❌ Ошибка при инициализации типов посылок: {e}")
            await session.rollback()
            raise


async def check_database_connection():
    """Проверить подключение к базе данных."""
    try:
        async with AsyncSessionLocal() as session:
            result = await session.execute(text("SELECT 1"))
            if result.scalar() == 1:
                print("✅ Подключение к базе данных успешно")
                return True
    except Exception as e:
        print(f"❌ Ошибка подключения к базе данных: {e}")
        return False
    
    return False


async def main():
    """Основная функция скрипта."""
    print("🚀 Запуск инициализации базы данных...")
    
    # Проверяем подключение
    if not await check_database_connection():
        print("❌ Не удалось подключиться к базе данных. Проверьте настройки.")
        sys.exit(1)
    
    try:
        # Инициализируем типы посылок
        await init_package_types()
        
        print("\n🎉 Инициализация базы данных завершена успешно!")
        
    except Exception as e:
        print(f"\n❌ Ошибка при инициализации: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\database\__init__.py --------------------
"""Infrastructure database module."""
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\external\cached_provider.py --------------------
"""
Cached provider wrapper around CBRCurrencyRatesProvider using Redis with TTL.
"""
from __future__ import annotations

import json
from datetime import datetime, timezone
from decimal import Decimal
from typing import Optional

from loguru import logger

from domain.ports.currency_rates_provider import CurrencyRatesProvider
from domain.value_objects.currency import Currency, Rate
from infrastructure.external.cbr_provider import CBRCurrencyRatesProvider
from infrastructure.redis.client import get_redis_client
from core.config import get_settings


class CachedCurrencyRatesProvider(CurrencyRatesProvider):
    """Redis-cached wrapper for currency rates."""

    KEY_USD_RUB = "rates:USD_RUB"

    def __init__(self, ttl_seconds: int = 600):
        self.ttl = ttl_seconds
        self.settings = get_settings()
        self._fallback = CBRCurrencyRatesProvider()

    async def __aenter__(self):
        await self._fallback.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb):
        await self._fallback.__aexit__(exc_type, exc, tb)

    async def get_usd_to_rub_rate(self) -> Optional[Rate]:
        return await self.get_rate(Currency.usd(), Currency.rub())

    async def get_rate(self, from_currency: Currency, to_currency: Currency) -> Optional[Rate]:
        if from_currency.code != Currency.USD or to_currency.code != Currency.RUB:
            return None

        redis = get_redis_client(db=self.settings.REDIS_DB_CACHE)
        if redis:
            try:
                data = await redis.get(self.KEY_USD_RUB)
            except Exception as e:
                logger.warning(f"Redis GET failed: {e}")
                data = None
            if data:
                try:
                    payload = json.loads(data)
                    value = Decimal(payload["value"])  # stored as string
                    updated_at = (
                        datetime.fromisoformat(payload["updated_at"]).astimezone(timezone.utc)
                        if payload.get("updated_at")
                        else None
                    )
                    return Rate.usd_to_rub(value, updated_at=updated_at)
                except Exception as e:
                    logger.warning(f"Failed to parse cached rate: {e}")

        # Fallback to real provider
        rate = await self._fallback.get_usd_to_rub_rate()
        if rate and redis:
            try:
                payload = {
                    "value": str(rate.value),
                    "updated_at": rate.updated_at.isoformat() if rate.updated_at else None,
                }
                await redis.set(self.KEY_USD_RUB, json.dumps(payload), ex=self.ttl)
            except Exception as e:
                logger.warning(f"Redis SET failed: {e}")
        return rate

    async def is_rate_available(self, from_currency: Currency, to_currency: Currency) -> bool:
        return from_currency.code == Currency.USD and to_currency.code == Currency.RUB
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\external\cbr_provider.py --------------------
"""
Провайдер курсов валют от ЦБ РФ.
Интеграция с https://www.cbr-xml-daily.ru/daily_json.js
"""
import asyncio
from decimal import Decimal
from typing import Optional
from datetime import datetime, timezone
import httpx
from loguru import logger

from domain.ports.currency_rates_provider import CurrencyRatesProvider
from domain.value_objects.currency import Rate, Currency
from core.config import get_settings


class CBRCurrencyRatesProvider(CurrencyRatesProvider):
    """Провайдер курсов валют от ЦБ РФ."""
    
    def __init__(self):
        self.settings = get_settings()
        self._client: Optional[httpx.AsyncClient] = None
    
    async def __aenter__(self):
        """Async context manager вход."""
        self._client = httpx.AsyncClient(
            timeout=httpx.Timeout(self.settings.CBR_TIMEOUT)
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager выход."""
        if self._client:
            await self._client.aclose()
    
    async def get_usd_to_rub_rate(self) -> Optional[Rate]:
        """Получить текущий курс USD -> RUB."""
        return await self.get_rate(Currency.usd(), Currency.rub())
    
    async def get_rate(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> Optional[Rate]:
        """
        Получить курс между двумя валютами.
        
        Args:
            from_currency: Исходная валюта
            to_currency: Целевая валюта
            
        Returns:
            Курс валют или None если не удалось получить
        """
        if from_currency.code == Currency.USD and to_currency.code == Currency.RUB:
            return await self._fetch_usd_to_rub_rate()
        
        logger.warning(f"Неподдерживаемая пара валют: {from_currency.code} -> {to_currency.code}")
        return None
    
    async def is_rate_available(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> bool:
        """Проверить, доступен ли курс между валютами."""
        return (
            from_currency.code == Currency.USD and 
            to_currency.code == Currency.RUB
        )
    
    async def _fetch_usd_to_rub_rate(self) -> Optional[Rate]:
        """Получить курс USD -> RUB от ЦБ РФ."""
        for attempt in range(self.settings.CBR_RETRY_COUNT):
            try:
                logger.info(f"Запрос курса USD/RUB от ЦБ РФ (попытка {attempt + 1})")
                
                if not self._client:
                    self._client = httpx.AsyncClient(
                        timeout=httpx.Timeout(self.settings.CBR_TIMEOUT)
                    )
                
                response = await self._client.get(self.settings.CBR_API_URL)
                response.raise_for_status()
                
                data = response.json()
                
                # Парсим JSON ответ
                usd_rate, updated_at = self._parse_usd_rate(data)
                
                if usd_rate:
                    logger.info(f"Получен курс USD/RUB: {usd_rate}")
                    return Rate.usd_to_rub(usd_rate, updated_at=updated_at)
                else:
                    logger.warning("USD не найден в ответе ЦБ РФ")
                    
            except httpx.TimeoutException:
                logger.warning(f"Таймаут при запросе к ЦБ РФ (попытка {attempt + 1})")
                if attempt < self.settings.CBR_RETRY_COUNT - 1:
                    await asyncio.sleep(2 ** attempt)  # Экспоненциальная задержка
                    
            except httpx.HTTPStatusError as e:
                logger.error(f"HTTP ошибка при запросе к ЦБ РФ: {e.response.status_code}")
                if attempt < self.settings.CBR_RETRY_COUNT - 1:
                    await asyncio.sleep(2 ** attempt)
                    
            except Exception as e:
                logger.error(f"Ошибка при запросе курса от ЦБ РФ: {e}")
                if attempt < self.settings.CBR_RETRY_COUNT - 1:
                    await asyncio.sleep(2 ** attempt)
        
        logger.error("Не удалось получить курс USD/RUB от ЦБ РФ после всех попыток")
        return None
    
    def _parse_usd_rate(self, data: dict) -> tuple[Optional[Decimal], Optional[datetime]]:
        """
        Извлечь курс USD из JSON ответа ЦБ РФ.
        
        Args:
            data: JSON ответ от ЦБ РФ
            
        Returns:
            Пара (курс USD или None, время обновления или None)
        """
        try:
            # Структура ответа: {"Valute": {"USD": {"Value": 95.67, "Nominal": 1}}}
            valute = data.get("Valute", {})
            usd_data = valute.get("USD")
            
            if not usd_data:
                return None, None
            
            value = usd_data.get("Value")
            nominal = usd_data.get("Nominal", 1)
            
            if value is None:
                return None, None
            
            # Курс = Значение / Номинал
            rate = Decimal(str(value)) / Decimal(str(nominal))
            # Время обновления: предпочитаем поле Date из корня, иначе Timestamp, иначе None
            updated_at: Optional[datetime] = None
            try:
                # Пример Date: "2024-06-06T11:30:00+03:00" или "2024-06-06T11:30:00"
                date_str = data.get("Date")
                if isinstance(date_str, str):
                    updated_at = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
                elif isinstance(data.get("Timestamp"), str):
                    updated_at = datetime.fromisoformat(data["Timestamp"].replace("Z", "+00:00"))
            except Exception:
                updated_at = None
            # Нормализуем в UTC
            if isinstance(updated_at, datetime) and updated_at.tzinfo is not None:
                updated_at = updated_at.astimezone(timezone.utc)
            return rate, updated_at
            
        except (KeyError, ValueError, TypeError) as e:
            logger.error(f"Ошибка парсинга курса USD: {e}")
            return None, None


class MockCBRProvider(CurrencyRatesProvider):
    """Мок-провайдер для тестирования."""
    
    def __init__(self, mock_rate: Decimal = Decimal("95.50")):
        self.mock_rate = mock_rate
    
    async def get_usd_to_rub_rate(self) -> Optional[Rate]:
        """Вернуть моковый курс."""
        return Rate.usd_to_rub(self.mock_rate)
    
    async def get_rate(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> Optional[Rate]:
        """Вернуть моковый курс для USD -> RUB."""
        if from_currency.code == Currency.USD and to_currency.code == Currency.RUB:
            return await self.get_usd_to_rub_rate()
        return None
    
    async def is_rate_available(
        self,
        from_currency: Currency,
        to_currency: Currency
    ) -> bool:
        """Проверить доступность курса."""
        return (
            from_currency.code == Currency.USD and 
            to_currency.code == Currency.RUB
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\external\__init__.py --------------------
"""Инициализация модуля infrastructure/external."""

from .cbr_provider import CBRCurrencyRatesProvider, MockCBRProvider

__all__ = [
    "CBRCurrencyRatesProvider",
    "MockCBRProvider"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\logging\config.py --------------------
"""
Конфигурация логирования с использованием loguru.
Интеграция с uvicorn access логами.
"""
import sys
from pathlib import Path
from loguru import logger


def setup_logging(debug: bool = False) -> None:
    """Настроить логирование для приложения."""
    
    # Очистить стандартные handlers
    logger.remove()
    
    # Формат для логов
    log_format = (
        "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
        "<level>{level: <8}</level> | "
        "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
        "<level>{message}</level>"
    )
    
    # Консольный вывод
    logger.add(
        sys.stderr,
        format=log_format,
        level="DEBUG" if debug else "INFO",
        colorize=True,
        backtrace=True,
        diagnose=True,
    )
    
    # Файловый вывод
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)
    
    # Основной лог
    logger.add(
        logs_dir / "app.log",
        format=log_format,
        level="DEBUG" if debug else "INFO",
        rotation="1 day",
        retention="30 days",
        compression="gz",
        backtrace=True,
        diagnose=True,
    )
    
    # Лог ошибок
    logger.add(
        logs_dir / "errors.log",
        format=log_format,
        level="ERROR",
        rotation="1 day",
        retention="30 days",
        compression="gz",
        backtrace=True,
        diagnose=True,
    )
    
    # Настройка уровня логирования для внешних библиотек
    if not debug:
        logger.disable("sqlalchemy.engine")


def get_logger(name: str) -> "logger":
    """Получить логгер с именем."""
    return logger.bind(name=name)


class InterceptHandler:
    """Handler для перехвата стандартных логов Python."""
    
    def emit(self, record):
        """Перенаправить лог в loguru."""
        # Получить соответствующий уровень Loguru
        try:
            level = logger.level(record.levelname).name
        except ValueError:
            level = record.levelno
        
        # Найти вызывающий фрейм
        frame, depth = sys._getframe(6), 6
        while frame and frame.f_code.co_filename == __file__:
            frame = frame.f_back
            depth += 1
        
        logger.opt(depth=depth, exception=record.exc_info).log(
            level, record.getMessage()
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\logging\__init__.py --------------------
"""Infrastructure logging module."""
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\redis\client.py --------------------
"""
Redis async client helpers.
"""
from __future__ import annotations

from typing import Optional
from redis import asyncio as aioredis

from core.config import get_settings


def get_redis_client(db: Optional[int] = None) -> Optional[aioredis.Redis]:
    """Return aioredis client or None if REDIS_URL not configured."""
    settings = get_settings()
    if not settings.REDIS_URL:
        return None
    url = settings.REDIS_URL
    if db is not None:
        # Override DB index by rewriting last path segment
        # redis://host:port/<db>
        if "/" in url:
            base = url.rsplit("/", 1)[0]
            url = f"{base}/{db}"
        else:
            url = f"{url}/{db}"
    return aioredis.from_url(url, encoding="utf-8", decode_responses=True)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\security\redis_session_repository.py --------------------
"""
Redis-backed implementation of SessionRepository with TTL.
"""
from __future__ import annotations

import json
from datetime import timedelta
from typing import Any, Dict, Optional

from domain.ports.session_repository import SessionRepository
from domain.value_objects.identifiers import SessionId
from infrastructure.redis.client import get_redis_client
from core.config import get_settings


class RedisSessionRepository(SessionRepository):
    def __init__(self) -> None:
        self.settings = get_settings()
        self._redis = get_redis_client(db=self.settings.REDIS_DB_SESSIONS)

    async def get_session_data(self, session_id: SessionId) -> Optional[Dict[str, Any]]:
        if not self._redis:
            return None
        data = await self._redis.get(self._key(session_id.value))  # type: ignore[attr-defined]
        if not data:
            return None
        try:
            return json.loads(data)
        except Exception:
            return None

    async def save_session_data(
        self, session_id: SessionId, data: Dict[str, Any], ttl: Optional[int] = None
    ) -> None:
        if not self._redis:
            return None
        ex = int(ttl) if ttl else None
        payload = json.dumps(data)
        await self._redis.set(self._key(session_id.value), payload, ex=ex)  # type: ignore[attr-defined]
        return None

    async def session_exists(self, session_id: SessionId) -> bool:
        if not self._redis:
            return False
        return bool(await self._redis.exists(self._key(session_id.value)))  # type: ignore[attr-defined]

    async def extend_session_ttl(self, session_id: SessionId, ttl: int) -> None:
        if not self._redis:
            return None
        await self._redis.expire(self._key(session_id.value), int(ttl))  # type: ignore[attr-defined]
        return None

    async def delete_session(self, session_id: SessionId) -> None:
        if not self._redis:
            return None
        await self._redis.delete(self._key(session_id.value))  # type: ignore[attr-defined]
        return None

    @staticmethod
    def _key(session_id: str) -> str:
        return f"session:{session_id}"
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\security\__init__.py --------------------
"""Infrastructure security module."""
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\sqlalchemy\database.py --------------------
# infrastructure/sqlalchemy/database.py
"""
Единая точка инициализации SQLAlchemy (async).
"""

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase

from core.config import get_settings

settings = get_settings()


class Base(DeclarativeBase):
    """Базовый класс моделей."""


# Приводим URL к async-схеме гарантированно
def _ensure_async_url(url: str) -> str:
    if url.startswith("postgresql+asyncpg://"):
        return url
    if url.startswith("postgresql://"):
        return url.replace("postgresql://", "postgresql+asyncpg://", 1)
    if url.startswith("postgres://"):
        # на случай короткой формы
        return url.replace("postgres://", "postgresql+asyncpg://", 1)
    # оставим как есть — вдруг указали другой драйвер
    return url


ASYNC_DATABASE_URL: str = _ensure_async_url(settings.ASYNC_DATABASE_URL)

async_engine: AsyncEngine = create_async_engine(
    ASYNC_DATABASE_URL,
    echo=False,
    future=True,
    pool_pre_ping=True,
)

AsyncSessionLocal = async_sessionmaker(
    bind=async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


# DI-зависимость для FastAPI
async def get_async_session() -> AsyncIterator[AsyncSession]:
    async with AsyncSessionLocal() as session:
        yield session


def create_session_factory_no_pool() -> async_sessionmaker[AsyncSession]:
    """
    Создать фабрику AsyncSession с отдельным движком без пула соединений.
    Полезно для задач (например, Celery), где важно избежать конфликтов event loop.
    """
    # Локальный импорт, чтобы избежать проблем статического анализа окружения
    from sqlalchemy.pool import NullPool  # type: ignore

    isolated_engine: AsyncEngine = create_async_engine(
        ASYNC_DATABASE_URL,
        echo=False,
        future=True,
        pool_pre_ping=True,
        poolclass=NullPool,
    )
    return async_sessionmaker(
        bind=isolated_engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\sqlalchemy\models.py --------------------
"""
ORM-модели для SQLAlchemy.
Package, PackageType, индексы, связи, default-ы.
"""
from datetime import datetime
from sqlalchemy import Column, Integer, String, Numeric, DateTime, ForeignKey, Index
from sqlalchemy.orm import relationship
from infrastructure.sqlalchemy.database import Base


class PackageTypeModel(Base):
    """ORM модель типа посылки."""
    __tablename__ = "package_types"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False, index=True)
    
    # Связь с посылками
    packages = relationship("PackageModel", back_populates="package_type")


class PackageModel(Base):
    """ORM модель посылки."""
    __tablename__ = "packages"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(200), nullable=False)
    weight = Column(Numeric(10, 3), nullable=False)  # килограммы с точностью до грамма
    value_usd = Column(Numeric(12, 2), nullable=False)  # доллары с центами
    session_id = Column(String(36), nullable=False, index=True)  # UUID
    delivery_price_rub = Column(Numeric(12, 2), nullable=True)  # рубли с копейками
    
    # Внешний ключ
    type_id = Column(Integer, ForeignKey("package_types.id"), nullable=False, index=True)
    
    # Временные метки
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Связи
    package_type = relationship("PackageTypeModel", back_populates="packages")
    
    # Индексы для оптимизации запросов
    __table_args__ = (
        Index("ix_packages_session_type", "session_id", "type_id"),
        Index("ix_packages_session_price", "session_id", "delivery_price_rub"),
        Index("ix_packages_no_price", "delivery_price_rub"),  # для поиска без цены
        Index("ix_packages_created", "created_at"),
    )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\sqlalchemy\package_repository.py --------------------
"""
Реализация репозитория посылок на SQLAlchemy.
"""
from typing import Optional, List
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from domain.entities.package import Package
from domain.ports.package_repository import PackageRepository
from domain.value_objects.identifiers import PackageId, SessionId
from infrastructure.sqlalchemy.models import PackageModel


class SQLAlchemyPackageRepository(PackageRepository):
    """Реализация репозитория посылок на SQLAlchemy."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def save(self, package: Package) -> Package:
        """Сохранить посылку."""
        if package.id.value == 0:
            # Создание новой посылки
            db_package = PackageModel(
                name=package.name,
                weight=package.weight,
                type_id=package.type_id,
                value_usd=package.value_usd,
                session_id=package.session_id,
                delivery_price_rub=package.delivery_price_rub
            )
            self.session.add(db_package)
            await self.session.flush()
            await self.session.refresh(db_package)
            await self.session.commit()
            
            # Обновляем доменную сущность с новым ID
            package.id = PackageId.from_int(db_package.id)
            package.created_at = db_package.created_at
            package.updated_at = db_package.updated_at
            
        else:
            # Обновление существующей посылки
            stmt = select(PackageModel).where(PackageModel.id == package.id.value)
            result = await self.session.execute(stmt)
            db_package = result.scalar_one_or_none()
            
            if not db_package:
                raise ValueError(f"Посылка с ID {package.id.value} не найдена")
            
            # Обновляем поля
            db_package.name = package.name
            db_package.weight = package.weight
            db_package.type_id = package.type_id
            db_package.value_usd = package.value_usd
            db_package.delivery_price_rub = package.delivery_price_rub
            
            await self.session.flush()
            await self.session.refresh(db_package)
            await self.session.commit()
            
            package.updated_at = db_package.updated_at
        
        return package
    
    async def get_by_id(self, package_id: PackageId) -> Optional[Package]:
        """Получить посылку по ID."""
        stmt = (
            select(PackageModel)
            .options(selectinload(PackageModel.package_type))
            .where(PackageModel.id == package_id.value)
        )
        result = await self.session.execute(stmt)
        db_package = result.scalar_one_or_none()
        
        if not db_package:
            return None
        
        return self._to_domain_entity(db_package)
    
    async def get_by_session_id(
        self,
        session_id: SessionId,
        type_id: Optional[int] = None,
        has_price: Optional[bool] = None,
        offset: int = 0,
        limit: int = 100
    ) -> List[Package]:
        """Получить посылки по session_id с фильтрами и пагинацией."""
        stmt = (
            select(PackageModel)
            .options(selectinload(PackageModel.package_type))
            .where(PackageModel.session_id == session_id.value)
        )
        
        # Применяем фильтры
        if type_id is not None:
            stmt = stmt.where(PackageModel.type_id == type_id)
        
        if has_price is not None:
            if has_price:
                stmt = stmt.where(PackageModel.delivery_price_rub.is_not(None))
            else:
                stmt = stmt.where(PackageModel.delivery_price_rub.is_(None))
        
        # Пагинация и сортировка
        stmt = stmt.order_by(PackageModel.created_at.desc())
        stmt = stmt.offset(offset).limit(limit)
        
        result = await self.session.execute(stmt)
        db_packages = result.scalars().all()
        
        return [self._to_domain_entity(db_package) for db_package in db_packages]
    
    async def count_by_session_id(
        self,
        session_id: SessionId,
        type_id: Optional[int] = None,
        has_price: Optional[bool] = None
    ) -> int:
        """Подсчитать количество посылок по session_id с фильтрами."""
        stmt = (
            select(func.count(PackageModel.id))
            .where(PackageModel.session_id == session_id.value)
        )
        
        # Применяем фильтры
        if type_id is not None:
            stmt = stmt.where(PackageModel.type_id == type_id)
        
        if has_price is not None:
            if has_price:
                stmt = stmt.where(PackageModel.delivery_price_rub.is_not(None))
            else:
                stmt = stmt.where(PackageModel.delivery_price_rub.is_(None))
        
        result = await self.session.execute(stmt)
        return result.scalar() or 0
    
    async def get_packages_without_price(self, limit: int = 100) -> List[Package]:
        """Получить посылки без рассчитанной цены доставки."""
        stmt = (
            select(PackageModel)
            .options(selectinload(PackageModel.package_type))
            .where(PackageModel.delivery_price_rub.is_(None))
            .order_by(PackageModel.created_at.asc())
            .limit(limit)
        )
        
        result = await self.session.execute(stmt)
        db_packages = result.scalars().all()
        
        return [self._to_domain_entity(db_package) for db_package in db_packages]
    
    async def update_delivery_prices(self, prices: dict[int, float]) -> int:
        """
        Обновить цены доставки для нескольких посылок.
        
        Args:
            prices: Словарь {package_id: delivery_price_rub}
            
        Returns:
            Количество обновленных записей
        """
        if not prices:
            return 0
        
        updated_count = 0
        
        for package_id, price in prices.items():
            stmt = (
                select(PackageModel)
                .where(PackageModel.id == package_id)
            )
            result = await self.session.execute(stmt)
            db_package = result.scalar_one_or_none()
            
            if db_package:
                db_package.delivery_price_rub = price
                updated_count += 1
        
        if updated_count:
            await self.session.commit()
        return updated_count
    
    def _to_domain_entity(self, db_package: PackageModel) -> Package:
        """Конвертировать ORM модель в доменную сущность."""
        return Package(
            id=PackageId.from_int(db_package.id),
            name=db_package.name,
            weight=db_package.weight,
            type_id=db_package.type_id,
            value_usd=db_package.value_usd,
            session_id=db_package.session_id,
            delivery_price_rub=db_package.delivery_price_rub,
            created_at=db_package.created_at,
            updated_at=db_package.updated_at
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\sqlalchemy\package_type_repository.py --------------------
"""
Реализация репозитория типов посылок на SQLAlchemy.
"""
from typing import Optional, List
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from domain.entities.package_type import PackageType
from domain.ports.package_type_repository import PackageTypeRepository
from infrastructure.sqlalchemy.models import PackageTypeModel


class SQLAlchemyPackageTypeRepository(PackageTypeRepository):
    """Реализация репозитория типов посылок на SQLAlchemy."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_id(self, type_id: int) -> Optional[PackageType]:
        """Получить тип посылки по ID."""
        stmt = select(PackageTypeModel).where(PackageTypeModel.id == type_id)
        result = await self.session.execute(stmt)
        db_type = result.scalar_one_or_none()
        
        if not db_type:
            return None
        
        return self._to_domain_entity(db_type)
    
    async def get_all(self) -> List[PackageType]:
        """Получить все типы посылок."""
        stmt = select(PackageTypeModel).order_by(PackageTypeModel.id)
        result = await self.session.execute(stmt)
        db_types = result.scalars().all()
        
        return [self._to_domain_entity(db_type) for db_type in db_types]

    async def get_by_name(self, name: str) -> Optional[PackageType]:
        """Получить тип посылки по названию."""
        stmt = select(PackageTypeModel).where(PackageTypeModel.name == name)
        result = await self.session.execute(stmt)
        db_type = result.scalar_one_or_none()
        if not db_type:
            return None
        return self._to_domain_entity(db_type)
    
    async def exists(self, type_id: int) -> bool:
        """Проверить существование типа посылки."""
        stmt = select(PackageTypeModel.id).where(PackageTypeModel.id == type_id)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none() is not None
    
    async def save(self, package_type: PackageType) -> PackageType:
        """Сохранить тип посылки."""
        # Проверяем, существует ли уже
        existing = await self.get_by_id(package_type.id)
        
        if existing:
            # Обновляем существующий
            stmt = select(PackageTypeModel).where(PackageTypeModel.id == package_type.id)
            result = await self.session.execute(stmt)
            db_type = result.scalar_one()
            
            db_type.name = package_type.name
        else:
            # Создаем новый
            db_type = PackageTypeModel(
                id=package_type.id,
                name=package_type.name
            )
            self.session.add(db_type)
        
        await self.session.flush()
        return package_type
    
    def _to_domain_entity(self, db_type: PackageTypeModel) -> PackageType:
        """Конвертировать ORM модель в доменную сущность."""
        return PackageType(
            id=db_type.id,
            name=db_type.name
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\sqlalchemy\__init__.py --------------------
# SQLAlchemy модели и репозитории
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\tasks\celery_app.py --------------------
"""
Конфигурация Celery приложения.
"""
from celery import Celery
from celery.schedules import crontab

from core.config import get_settings

settings = get_settings()

# Создание Celery приложения
celery_app = Celery(
    "delivery_app",
    broker=settings.CELERY_BROKER_URL,
    backend=settings.CELERY_RESULT_BACKEND,
    include=[
        "infrastructure.tasks.currency_tasks",
        "infrastructure.tasks.delivery_tasks"
    ]
)

# Конфигурация Celery
celery_app.conf.update(
    # Настройки задач
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
    
    # Настройки worker'а
    worker_prefetch_multiplier=1,
    task_acks_late=True,
    worker_max_tasks_per_child=1000,
    # Включаем события/статусы для Flower
    worker_send_task_events=True,
    task_track_started=True,
    
    # Настройки результатов
    result_expires=3600,  # 1 час
    # Отправлять событие "task-sent" при публикации задач
    task_send_sent_event=True,
    
    # Расписание периодических задач
    beat_schedule={
        "update-currency-rates": {
            "task": "infrastructure.tasks.currency_tasks.update_currency_rates",
            "schedule": crontab(minute="*/5"),  # Каждые 5 минут
        },
        "calculate-delivery-prices": {
            "task": "infrastructure.tasks.delivery_tasks.calculate_delivery_prices",
            "schedule": crontab(minute="*/5"),  # Каждые 5 минут
        },
    },
)


@celery_app.task(bind=True)
def debug_task(self):
    """Отладочная задача."""
    print(f'Request: {self.request!r}')
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\tasks\currency_tasks.py --------------------
"""
Задачи для работы с курсами валют.
"""
from loguru import logger
from typing import Optional
from infrastructure.tasks.celery_app import celery_app
from presentation.dependencies.container import di_container
from domain.ports.currency_rates_provider import CurrencyRatesProvider
from domain.value_objects.currency import Currency
import asyncio


from domain.value_objects.currency import Rate


async def _fetch_usd_rub_rate() -> Optional[Rate]:
    """Асинхронно получить курс USD->RUB через DI-провайдер.

    Возвращает value-object Currency или None.
    """
    provider: CurrencyRatesProvider = di_container.get_currency_rates_provider()
    async with provider:  # type: ignore[attr-defined]
        return await provider.get_usd_to_rub_rate()


@celery_app.task(bind=True, max_retries=3)
def update_currency_rates(self):
    """
    Обновить курсы валют от ЦБ РФ.
    Выполняется каждые 5 минут.
    """
    try:
        logger.info("Запуск задачи обновления курсов валют")
        # Получаем курс USD -> RUB через общий helper
        rate = asyncio.run(_fetch_usd_rub_rate())

        if rate:
            logger.info(f"Курс USD/RUB получен: {rate.value}")
            return {"status": "success", "rate": str(rate.value)}
        else:
            logger.warning("Не удалось получить курс валют")
            # Повторяем задачу через 2 минуты
            raise self.retry(countdown=120)

    except Exception as exc:
        logger.error(f"Ошибка при обновлении курсов валют: {exc}")

        if self.request.retries < self.max_retries:
            logger.info(
                f"Повтор задачи через 5 минут (попытка {self.request.retries + 1})"
            )
            raise self.retry(countdown=300, exc=exc)
        else:
            logger.error("Исчерпаны все попытки обновления курсов валют")
            return {
                "status": "error",
                "message": f"Не удалось обновить курсы валют: {str(exc)}",
            }

 
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\tasks\delivery_tasks.py --------------------
"""
Задачи для расчета стоимости доставки.
"""
from loguru import logger
from infrastructure.tasks.celery_app import celery_app
from infrastructure.sqlalchemy.database import create_session_factory_no_pool
from domain.services.delivery_pricing import DeliveryPricingService
from domain.ports.currency_rates_provider import CurrencyRatesProvider
from infrastructure.sqlalchemy.package_repository import SQLAlchemyPackageRepository
from presentation.dependencies.container import di_container
from domain.ports.session_repository import SessionRepository


@celery_app.task(bind=True, max_retries=2)
def calculate_delivery_prices(self, limit: int = 100):
    """
    Рассчитать стоимость доставки для посылок без цены.
    Выполняется каждые 5 минут.
    """
    try:
        logger.info(f"Запуск расчета стоимости доставки (лимит: {limit})")
        
        async def process_packages():
            session_factory = create_session_factory_no_pool()
            async with session_factory() as session:
                # Репозитории
                package_repo = SQLAlchemyPackageRepository(session)
                
                # Получаем посылки без цены
                packages = await package_repo.get_packages_without_price(limit)
                
                if not packages:
                    logger.info("Нет посылок для расчета стоимости доставки")
                    return {"status": "success", "processed": 0, "message": "Нет посылок для обработки"}
                
                logger.info(f"Найдено {len(packages)} посылок для расчета")
                
                # Получаем курс валют через провайдер из DI
                provider: CurrencyRatesProvider = di_container.get_currency_rates_provider()
                async with provider:  # type: ignore[attr-defined]
                    rate = await provider.get_usd_to_rub_rate()
                
                if not rate:
                    logger.warning("Не удалось получить курс USD/RUB")
                    return {"status": "error", "message": "Курс валют недоступен"}
                
                # Сервис расчета
                pricing_service = DeliveryPricingService()
                
                # Рассчитываем цены
                processed_count = 0
                errors = []
                prices_batch: dict[int, float] = {}

                for package in packages:
                    try:
                        delivery_price = pricing_service.calculate_delivery_price(package, rate)
                        # Сохраняем для батч‑обновления (как float для совместимости с Numeric)
                        prices_batch[package.id.value] = float(delivery_price)
                    except Exception as e:
                        error_msg = f"Ошибка расчета для посылки {package.id.value}: {str(e)}"
                        logger.error(error_msg)
                        errors.append(error_msg)

                if prices_batch:
                    processed_count = await package_repo.update_delivery_prices(prices_batch)
                    await session.commit()

                result = {
                    "status": "success",
                    "processed": processed_count,
                    "errors": len(errors),
                    "rate_used": str(rate.value)
                }
                
                if errors:
                    result["error_details"] = errors[:5]  # Первые 5 ошибок
                
                logger.info(f"Завершен расчет: обработано {processed_count} посылок, ошибок {len(errors)}")
                return result
        
        import asyncio
        return asyncio.run(process_packages())
        
    except Exception as exc:
        logger.error(f"Критическая ошибка при расчете стоимости доставки: {exc}")
        
        if self.request.retries < self.max_retries:
            logger.info(f"Повтор задачи через 10 минут (попытка {self.request.retries + 1})")
            raise self.retry(countdown=600, exc=exc)
        else:
            return {
                "status": "error",
                "message": f"Критическая ошибка: {str(exc)}"
            }


@celery_app.task
def cleanup_expired_sessions():
    """
    Очистить истекшие сессии.
    Выполняется ежедневно.
    """
    try:
        logger.info("Запуск очистки истекших сессий")
        
        async def cleanup():
            # В текущем контракте SessionRepository нет метода очистки TTL.
            # Если понадобится — добавить в порт. Пока просто возвращаем 0.
            repo: SessionRepository = di_container.get_session_repository()
            # Ничего не делаем, так как нет метода в порту
            return 0
        
        import asyncio
        expired_count = asyncio.run(cleanup())
        
        logger.info(f"Очищено {expired_count} истекших сессий")
        return {
            "status": "success",
            "expired_sessions": expired_count
        }
        
    except Exception as exc:
        logger.error(f"Ошибка при очистке сессий: {exc}")
        return {
            "status": "error",
            "message": str(exc)
        }


@celery_app.task
def get_packages_without_price_count():
    """
    Получить количество посылок без рассчитанной цены (для мониторинга).
    """
    try:
        async def count_packages():
            session_factory = create_session_factory_no_pool()
            async with session_factory() as session:
                package_repo = SQLAlchemyPackageRepository(session)
                packages = await package_repo.get_packages_without_price(limit=1000)
                return len(packages)

        import asyncio
        count = asyncio.run(count_packages())
        
        return {
            "status": "success",
            "packages_without_price": count
        }
        
    except Exception as exc:
        logger.error(f"Ошибка при подсчете посылок: {exc}")
        return {
            "status": "error",
            "message": str(exc)
        }
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\infrastructure\tasks\__init__.py --------------------
"""Инициализация модуля infrastructure/tasks."""

from .celery_app import celery_app

__all__ = [
    "celery_app"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\logs\app.log --------------------
2025-09-01 05:37:32.252 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/health/ping | Query: {} | Client: 172.18.0.1
2025-09-01 05:37:32.258 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/health/ping | Status: 404 | Time: 0.006s
2025-09-01 05:37:32.368 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/health/health | Query: {} | Client: 172.18.0.1
2025-09-01 05:37:32.370 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/health/health | Status: 404 | Time: 0.002s
2025-09-01 05:37:32.382 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/package-types | Query: {} | Client: 172.18.0.1
2025-09-01 05:37:32.389 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/package-types | Status: 200 | Time: 0.007s
2025-09-01 05:37:54.747 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/ping | Query: {} | Client: 172.18.0.1
2025-09-01 05:37:54.748 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/ping | Status: 200 | Time: 0.001s
2025-09-01 05:37:54.800 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/health | Query: {} | Client: 172.18.0.1
2025-09-01 05:37:54.822 | INFO     | infrastructure.external.cbr_provider:_fetch_usd_to_rub_rate:76 | Запрос курса USD/RUB от ЦБ РФ (попытка 1)
2025-09-01 05:37:55.457 | INFO     | infrastructure.external.cbr_provider:_fetch_usd_to_rub_rate:92 | Получен курс USD/RUB: 80.3316
2025-09-01 05:37:55.459 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/health | Status: 200 | Time: 0.659s
2025-09-01 05:39:32.099 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: POST /api/v1/delivery/calculate | Query: {} | Client: 172.18.0.1
2025-09-01 05:39:32.345 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: POST /api/v1/delivery/calculate | Status: 200 | Time: 0.246s
2025-09-01 05:39:32.453 | INFO     | presentation.middleware.logging_middleware:logging_middleware:19 | Входящий запрос: GET /api/v1/delivery/exchange-rate | Query: {} | Client: 172.18.0.1
2025-09-01 05:39:32.475 | INFO     | presentation.middleware.logging_middleware:logging_middleware:32 | Ответ: GET /api/v1/delivery/exchange-rate | Status: 200 | Time: 0.022s
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\logs\errors.log --------------------
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\logs\flower.db --------------------
ϚW             	          @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\migrations\alembic.ini --------------------
# A generic, single database configuration.

[alembic]
# path to migration scripts (исправлено)
script_location = migrations/alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

prepend_sys_path = .

# timezone =

# truncate_slug_length = 40
# revision_environment = false
# sourceless = false

version_num_format = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d

# использовать разделитель ОС
version_path_separator = os

# output_encoding = utf-8

# sqlalchemy.url: для Alembic v1+ часто игнорируется и берётся из env.py.
# Если хочешь — оставь пустым/закомменченным и настраивай URL в env.py из переменных окружения.
# Если всё же прописывать тут, помни: Alembic работает на СИНХРОННОМ драйвере.
# Для PostgreSQL: "postgresql+psycopg2://user:pass@host:5432/db"
# (НЕ asyncpg)
# sqlalchemy.url = postgresql+psycopg2://postgres:password@db:5432/delivery_app
sqlalchemy.url =

[post_write_hooks]
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\migrations\alembic\env.py --------------------
# migrations/alembic/env.py
"""
Alembic (async) конфигурация:

"""

from __future__ import annotations

import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

# Логгирование alembic
config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Импортируем единую метадату
from core.config import get_settings  # noqa: E402
from infrastructure.sqlalchemy.database import Base  # noqa: E402
# Важно: импортируем модели, чтобы Base.metadata содержала все таблицы для autogenerate
from infrastructure.sqlalchemy import models  # noqa: F401,E402

# Важно: чтобы метадата включала все модели, они должны быть импортированы где-то до обращения к Base.metadata
# Если модели объявлены в отдельных модулях – простого импорта достаточно:
# from infrastructure.sqlalchemy import models  # noqa: F401

target_metadata = Base.metadata


def _async_url() -> str:
    settings = get_settings()
    return settings.ASYNC_DATABASE_URL


def _sync_url_for_offline(async_url: str) -> str:
    """
    Для offline режима alembic лучше указывать sync-URL (без +asyncpg).
    """
    if async_url.startswith("postgresql+asyncpg://"):
        return async_url.replace("postgresql+asyncpg://", "postgresql://", 1)
    if async_url.startswith("postgres://"):
        return async_url.replace("postgres://", "postgresql://", 1)
    return async_url


def run_migrations_offline() -> None:
    """Запуск миграций в 'offline' режиме (без подключения к БД)."""
    url = _sync_url_for_offline(_async_url())
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def _do_run_migrations(connection) -> None:
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
        compare_server_default=True,
    )
    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """Запуск миграций в 'online' режиме через AsyncEngine."""
    connectable: AsyncEngine = create_async_engine(_async_url(), future=True)

    async with connectable.connect() as connection:
        await connection.run_sync(_do_run_migrations)

    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\migrations\alembic\script.py.mako --------------------
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\migrations\alembic\versions\001_create_package_tables.py --------------------
"""Create package_types and packages tables

Revision ID: 001
Revises: 
Create Date: 2025-08-28 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy import Index


# revision identifiers, used by Alembic.
revision = '001'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Создание таблицы package_types
    op.create_table(
        'package_types',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=50), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('name')
    )
    
    # Создание индекса для package_types
    op.create_index('ix_package_types_id', 'package_types', ['id'])
    op.create_index('ix_package_types_name', 'package_types', ['name'])
    
    # Создание таблицы packages
    op.create_table(
        'packages',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=200), nullable=False),
        sa.Column('weight', sa.Numeric(precision=10, scale=3), nullable=False),
        sa.Column('value_usd', sa.Numeric(precision=12, scale=2), nullable=False),
        sa.Column('session_id', sa.String(length=36), nullable=False),
        sa.Column('delivery_price_rub', sa.Numeric(precision=12, scale=2), nullable=True),
        sa.Column('type_id', sa.Integer(), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.ForeignKeyConstraint(['type_id'], ['package_types.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    
    # Создание индексов для packages
    op.create_index('ix_packages_id', 'packages', ['id'])
    op.create_index('ix_packages_session_id', 'packages', ['session_id'])
    op.create_index('ix_packages_type_id', 'packages', ['type_id'])
    op.create_index('ix_packages_created', 'packages', ['created_at'])
    
    # Композитные индексы для оптимизации запросов
    op.create_index('ix_packages_session_type', 'packages', ['session_id', 'type_id'])
    op.create_index('ix_packages_session_price', 'packages', ['session_id', 'delivery_price_rub'])
    op.create_index('ix_packages_no_price', 'packages', ['delivery_price_rub'])


def downgrade() -> None:
    # Удаление индексов packages
    op.drop_index('ix_packages_no_price', table_name='packages')
    op.drop_index('ix_packages_session_price', table_name='packages')
    op.drop_index('ix_packages_session_type', table_name='packages')
    op.drop_index('ix_packages_created', table_name='packages')
    op.drop_index('ix_packages_type_id', table_name='packages')
    op.drop_index('ix_packages_session_id', table_name='packages')
    op.drop_index('ix_packages_id', table_name='packages')
    
    # Удаление таблицы packages
    op.drop_table('packages')
    
    # Удаление индексов package_types
    op.drop_index('ix_package_types_name', table_name='package_types')
    op.drop_index('ix_package_types_id', table_name='package_types')
    
    # Удаление таблицы package_types
    op.drop_table('package_types')
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\fastapi.py --------------------
"""
Создание и настройка FastAPI приложения.
Сборка FastAPI: роутеры, DI, OpenAPI/Swagger.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from infrastructure.logging.config import setup_logging, get_logger

from core.config import get_settings
from presentation.middleware import error_handling_middleware, logging_middleware


def create_app() -> FastAPI:
    """Создать и настроить FastAPI приложение."""
    settings = get_settings()
    
    # Создание приложения
    app = FastAPI(
        title=settings.APP_NAME,
        description="API для расчёта стоимости доставки посылок",
        version="1.0.0",
        docs_url=settings.DOCS_URL,
        redoc_url=settings.REDOC_URL,
        openapi_url=settings.OPENAPI_URL,
    )
    
    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Кастомные middleware (сначала логирование, затем обработка ошибок)
    app.middleware("http")(logging_middleware)
    app.middleware("http")(error_handling_middleware)
    
    # Подключение роутеров
    from presentation.routers import packages, package_types, delivery, health
    
    app.include_router(packages.router, prefix="/api/v1", tags=["packages"])
    app.include_router(package_types.router, prefix="/api/v1", tags=["package-types"])
    app.include_router(delivery.router, prefix="/api/v1", tags=["delivery"])
    app.include_router(health.router, prefix="/api/v1", tags=["health"])
    
    # События жизненного цикла
    @app.on_event("startup")
    async def startup_event():
        """Действия при запуске приложения."""
        # Настройка логирования
        setup_logging(debug=settings.DEBUG)
        logger = get_logger("startup")
        # Инициализация типов посылок
        from infrastructure.database.init_db import init_package_types
        try:
            await init_package_types()
        except Exception as e:
            logger.exception(f"Ошибка инициализации типов посылок: {e}")
    
    return app
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\__init__.py --------------------
# Presentation модуль - веб-слой FastAPI
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\dependencies\container.py --------------------
# presentation/dependencies/container.py

from __future__ import annotations

from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import AsyncSession

from core.config import get_settings
from infrastructure.sqlalchemy.database import AsyncSessionLocal
from infrastructure.sqlalchemy.package_repository import SQLAlchemyPackageRepository
from infrastructure.sqlalchemy.package_type_repository import SQLAlchemyPackageTypeRepository
from infrastructure.external.cbr_provider import CBRCurrencyRatesProvider
from infrastructure.external.cached_provider import CachedCurrencyRatesProvider

# Всегда используем Redis-хранилище сессий
from infrastructure.security.redis_session_repository import RedisSessionRepository

from domain.ports.package_repository import PackageRepository
from domain.ports.package_type_repository import PackageTypeRepository
from domain.ports.session_repository import SessionRepository
from domain.ports.currency_rates_provider import CurrencyRatesProvider

from application.use_cases.register_package import RegisterPackageUseCase
from application.use_cases.get_packages import GetPackagesUseCase
from application.use_cases.get_package_details import GetPackageDetailsUseCase
from application.use_cases.get_package_types import GetPackageTypesUseCase


class DIContainer:
    """Контейнер зависимостей приложения."""

    def __init__(self) -> None:
        self.settings = get_settings()
        # Полная реализация интерфейса SessionRepository (в т.ч. delete_session)
        # Всегда используем Redis-хранилище сессий; без REDIS_URL работа сессий невозможна
        self._session_repository: SessionRepository = RedisSessionRepository()
        self._currency_provider: CurrencyRatesProvider | None = None

    async def get_db_session(self) -> AsyncGenerator[AsyncSession, None]:
        async with AsyncSessionLocal() as session:
            try:
                yield session
            finally:
                await session.close()

    # --- Repositories ---

    def get_package_repository(self, session: AsyncSession) -> PackageRepository:
        return SQLAlchemyPackageRepository(session)

    def get_package_type_repository(
        self, session: AsyncSession
    ) -> PackageTypeRepository:
        return SQLAlchemyPackageTypeRepository(session)

    def get_session_repository(self) -> SessionRepository:
        return self._session_repository

    # --- External providers ---

    def get_currency_rates_provider(self) -> CurrencyRatesProvider:
        # Если доступен Redis — используем кэшируемый провайдер
        if self.settings.REDIS_URL:
            return CachedCurrencyRatesProvider(ttl_seconds=600)
        return CBRCurrencyRatesProvider()

    # --- Use cases ---

    async def get_register_package_use_case(
        self, session: AsyncSession
    ) -> RegisterPackageUseCase:
        return RegisterPackageUseCase(
            self.get_package_repository(session),
            self.get_package_type_repository(session),
        )

    async def get_get_packages_use_case(
        self, session: AsyncSession
    ) -> GetPackagesUseCase:
        return GetPackagesUseCase(
            self.get_package_repository(session),
            self.get_package_type_repository(session),
        )

    async def get_get_package_details_use_case(
        self, session: AsyncSession
    ) -> GetPackageDetailsUseCase:
        return GetPackageDetailsUseCase(
            self.get_package_repository(session),
            self.get_package_type_repository(session),
        )

    async def get_get_package_types_use_case(
        self, session: AsyncSession
    ) -> GetPackageTypesUseCase:
        return GetPackageTypesUseCase(self.get_package_type_repository(session))


# Глобальный контейнер для зависимостей FastAPI
di_container = DIContainer()
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\dependencies\di_deps.py --------------------
"""
Зависимости FastAPI для интеграции с DI контейнером.
"""
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from presentation.dependencies.container import di_container
from application.use_cases.register_package import RegisterPackageUseCase
from application.use_cases.get_packages import GetPackagesUseCase
from application.use_cases.get_package_details import GetPackageDetailsUseCase
from application.use_cases.get_package_types import GetPackageTypesUseCase


# Зависимости для базы данных
async def get_db_session():
    """Получить сессию базы данных."""
    async for session in di_container.get_db_session():
        yield session


# Зависимости для Use Cases
async def get_register_package_use_case(
    session: AsyncSession = Depends(get_db_session)
) -> RegisterPackageUseCase:
    """Получить use case регистрации посылки."""
    return await di_container.get_register_package_use_case(session)


async def get_get_packages_use_case(
    session: AsyncSession = Depends(get_db_session)
) -> GetPackagesUseCase:
    """Получить use case получения списка посылок."""
    return await di_container.get_get_packages_use_case(session)


async def get_get_package_details_use_case(
    session: AsyncSession = Depends(get_db_session)
) -> GetPackageDetailsUseCase:
    """Получить use case получения деталей посылки."""
    return await di_container.get_get_package_details_use_case(session)


async def get_get_package_types_use_case(
    session: AsyncSession = Depends(get_db_session)
) -> GetPackageTypesUseCase:
    """Получить use case получения типов посылок."""
    return await di_container.get_get_package_types_use_case(session)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\dependencies\session_deps.py --------------------
"""
Зависимости для управления сессиями без авторизации.
Cookie-based сессии для отслеживания пользователей.
"""
import uuid
from typing import Optional
from fastapi import Request, Response, Depends, HTTPException

from core.config import get_settings


def get_or_create_session_id(
    request: Request, 
    response: Response
) -> str:
    """
    Получить или создать ID сессии из cookies.
    
    Args:
        request: FastAPI запрос
        response: FastAPI ответ
        
    Returns:
        ID сессии
    """
    settings = get_settings()
    
    # Пытаемся получить существующую сессию
    session_id = request.cookies.get(settings.SESSION_COOKIE_NAME)
    
    if session_id and _is_valid_session_id(session_id):
        return session_id
    
    # Создаем новую сессию
    new_session_id = str(uuid.uuid4())
    
    # Устанавливаем cookie
    response.set_cookie(
        key=settings.SESSION_COOKIE_NAME,
        value=new_session_id,
        max_age=settings.SESSION_COOKIE_MAX_AGE,
        secure=settings.SESSION_COOKIE_SECURE,
        httponly=settings.SESSION_COOKIE_HTTPONLY,
        samesite=settings.SESSION_COOKIE_SAMESITE,
    )
    
    return new_session_id


def get_session_id(request: Request) -> str:
    """
    Получить ID сессии из cookies (только для чтения).
    
    Args:
        request: FastAPI запрос
        
    Returns:
        ID сессии
        
    Raises:
        HTTPException: Если сессия не найдена
    """
    settings = get_settings()
    
    session_id = request.cookies.get(settings.SESSION_COOKIE_NAME)
    
    if not session_id or not _is_valid_session_id(session_id):
        raise HTTPException(
            status_code=401,
            detail="Сессия не найдена. Зарегистрируйте посылку для создания сессии."
        )
    
    return session_id


def get_optional_session_id(request: Request) -> Optional[str]:
    """
    Получить ID сессии из cookies (опционально).
    
    Args:
        request: FastAPI запрос
        
    Returns:
        ID сессии или None
    """
    settings = get_settings()
    
    session_id = request.cookies.get(settings.SESSION_COOKIE_NAME)
    
    if session_id and _is_valid_session_id(session_id):
        return session_id
    
    return None


def _is_valid_session_id(session_id: str) -> bool:
    """
    Проверить валидность ID сессии.
    
    Args:
        session_id: ID сессии для проверки
        
    Returns:
        True если ID валиден, False иначе
    """
    if not session_id:
        return False
    
    # Проверяем формат UUID
    try:
        uuid.UUID(session_id)
        return True
    except ValueError:
        return False


class SessionDependency:
    """Класс для управления зависимостями сессий."""
    
    def __init__(self, auto_create: bool = True):
        """
        Инициализация.
        
        Args:
            auto_create: Автоматически создавать сессию если её нет
        """
        self.auto_create = auto_create
    
    def __call__(self, request: Request, response: Response) -> str:
        """
        Dependency для получения/создания сессии.
        
        Args:
            request: FastAPI запрос
            response: FastAPI ответ
            
        Returns:
            ID сессии
        """
        if self.auto_create:
            return get_or_create_session_id(request, response)
        else:
            return get_session_id(request)


# Предконфигурированные dependency
auto_session = SessionDependency(auto_create=True)
require_session = SessionDependency(auto_create=False)
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\dependencies\__init__.py --------------------
"""Инициализация модуля presentation/dependencies."""

from .session_deps import (
    get_session_id,
    get_or_create_session_id,
    get_optional_session_id,
    auto_session,
    require_session,
    SessionDependency
)

from .di_deps import (
    get_db_session,
    get_register_package_use_case,
    get_get_packages_use_case,
    get_get_package_details_use_case,
    get_get_package_types_use_case
)

__all__ = [
    "get_session_id",
    "get_or_create_session_id", 
    "get_optional_session_id",
    "auto_session",
    "require_session",
    "SessionDependency",
    "get_db_session",
    "get_register_package_use_case",
    "get_get_packages_use_case",
    "get_get_package_details_use_case",
    "get_get_package_types_use_case"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\middleware\error_middleware.py --------------------
"""
Middleware для обработки ошибок приложения.
"""
import traceback
from typing import Callable
from fastapi import Request, Response, HTTPException
from fastapi.responses import JSONResponse
from loguru import logger

from core.exceptions import AppError, ValidationError, NotFoundError, ExternalServiceError


async def error_handling_middleware(request: Request, call_next: Callable) -> Response:
    """
    Middleware для обработки ошибок приложения.
    
    Перехватывает исключения и преобразует их в стандартизированные JSON ответы.
    """
    try:
        response = await call_next(request)
        return response
        
    except HTTPException:
        # HTTPException уже обработаны FastAPI, пропускаем
        raise
        
    except ValidationError as e:
        logger.warning(f"Ошибка валидации: {e.message} | Детали: {e.details}")
        return JSONResponse(
            status_code=400,
            content={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
        
    except NotFoundError as e:
        logger.info(f"Ресурс не найден: {e.message}")
        return JSONResponse(
            status_code=404,
            content={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
        
    except ExternalServiceError as e:
        logger.error(f"Ошибка внешнего сервиса: {e.message} | Детали: {e.details}")
        return JSONResponse(
            status_code=502,
            content={
                "error": True,
                "message": "Ошибка внешнего сервиса",
                "error_code": e.error_code,
                "details": {"service": e.details.get("service_name", "unknown")}
            }
        )
        
    except AppError as e:
        logger.error(f"Ошибка приложения: {e.message} | Детали: {e.details}")
        return JSONResponse(
            status_code=500,
            content={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
        
    except Exception as e:
        # Неожиданная ошибка
        logger.error(f"Неожиданная ошибка: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        
        return JSONResponse(
            status_code=500,
            content={
                "error": True,
                "message": "Внутренняя ошибка сервера",
                "error_code": "INTERNAL_ERROR",
                "details": {}
            }
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\middleware\logging_middleware.py --------------------
"""
Middleware для логирования запросов.
"""
import time
from typing import Callable
from fastapi import Request, Response
from loguru import logger


async def logging_middleware(request: Request, call_next: Callable) -> Response:
    """
    Middleware для логирования HTTP запросов.
    
    Логирует информацию о входящих запросах и их обработке.
    """
    start_time = time.time()
    
    # Логируем входящий запрос
    logger.info(
        f"Входящий запрос: {request.method} {request.url.path} | "
        f"Query: {dict(request.query_params)} | "
        f"Client: {request.client.host if request.client else 'unknown'}"
    )
    
    # Обрабатываем запрос
    response = await call_next(request)
    
    # Вычисляем время обработки
    process_time = time.time() - start_time
    
    # Логируем ответ
    logger.info(
        f"Ответ: {request.method} {request.url.path} | "
        f"Status: {response.status_code} | "
        f"Time: {process_time:.3f}s"
    )
    
    # Добавляем заголовок с временем обработки
    response.headers["X-Process-Time"] = str(process_time)
    
    return response
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\middleware\__init__.py --------------------
"""Инициализация модуля presentation/middleware."""

from .error_middleware import error_handling_middleware
from .logging_middleware import logging_middleware

__all__ = [
    "error_handling_middleware",
    "logging_middleware"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\routers\delivery.py --------------------
"""
Роутер для работы с доставкой и периодическими задачами.
"""
from fastapi import APIRouter, Depends, HTTPException

from presentation.schemas.delivery_schemas import (
    TriggerCalculationRequest,
    TriggerCalculationResponse,
    ExchangeRateResponse
)
from presentation.schemas.error_schemas import ErrorResponse
from infrastructure.tasks.delivery_tasks import calculate_delivery_prices
from domain.ports.currency_rates_provider import CurrencyRatesProvider
from infrastructure.tasks.currency_tasks import update_currency_rates
from presentation.dependencies.container import di_container

router = APIRouter()

# TODO: Dependency Injection будет настроен в bootstrap
def get_currency_provider() -> CurrencyRatesProvider:
    # Возьмем провайдера из DI (может быть кэшированным)
    return di_container.get_currency_rates_provider()


@router.post(
    "/delivery/calculate",
    response_model=TriggerCalculationResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Ошибка валидации"},
        500: {"model": ErrorResponse, "description": "Внутренняя ошибка сервера"}
    },
    summary="Запустить расчет цен доставки",
    description="Принудительно запускает расчет стоимости доставки для посылок без цены"
)
async def trigger_calculation(
    request: TriggerCalculationRequest = TriggerCalculationRequest(),
):
    """Запустить расчет стоимости доставки."""
    try:
        task = calculate_delivery_prices.delay(request.limit)

        return TriggerCalculationResponse(
            task_id=task.id,
            message="Расчет цен запущен в фоновом режиме",
            packages_count=request.limit  # Приблизительно
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": f"Ошибка запуска расчета: {str(e)}",
                "error_code": "CALCULATION_ERROR"
            }
        )


@router.get(
    "/delivery/exchange-rate",
    response_model=ExchangeRateResponse,
    responses={
        500: {"model": ErrorResponse, "description": "Внутренняя ошибка сервера"}
    },
    summary="Получить текущий курс доллара",
    description="Возвращает актуальный курс USD/RUB из кэша или ЦБ РФ"
)
async def get_exchange_rate(
    currency_provider: CurrencyRatesProvider = Depends(get_currency_provider)
):
    task = update_currency_rates.delay()

    """Получить текущий курс USD/RUB."""
    try:
        # Получаем курс
        async with currency_provider:
            rate = await currency_provider.get_usd_to_rub_rate()
        
        if not rate:
            raise HTTPException(
                status_code=503,
                detail={
                    "error": True,
                    "message": "Курс валют временно недоступен.",
                    "error_code": "RATE_NOT_AVAILABLE"
                }
            )
        
        return ExchangeRateResponse(
            task_id=task.id,
            rate=rate.value,
            source="CBR",
            cached=False,
            updated_at=(rate.updated_at.isoformat() if getattr(rate, "updated_at", None) else None)  
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": f"Ошибка получения курса: {str(e)}",
                "error_code": "RATE_ERROR"
            }
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\routers\health.py --------------------
"""
Роутер для проверки здоровья сервиса.
"""
import time
from datetime import datetime
from fastapi import APIRouter
from sqlalchemy import text

from presentation.schemas.health_schemas import HealthCheckResponse
from infrastructure.sqlalchemy.database import AsyncSessionLocal
from infrastructure.external.cbr_provider import CBRCurrencyRatesProvider

router = APIRouter()


@router.get(
    "/health",
    response_model=HealthCheckResponse,
    summary="Проверка здоровья сервиса",
    description="Возвращает статус всех компонентов системы"
)
async def health_check():
    """Проверить здоровье всех компонентов системы."""
    timestamp = datetime.utcnow().isoformat() + "Z"
    checks = {}
    overall_status = "healthy"

    # Проверка базы данных
    db_status, db_time = await _measure_component(_check_database)
    checks["database"] = {
        "status": db_status,
        "response_time": f"{db_time:.3f}s"
    }
    if db_status != "healthy":
        overall_status = "unhealthy"

    # Проверка CBR API
    cbr_status, cbr_time = await _measure_component(_check_cbr_api)
    checks["cbr_api"] = {
        "status": cbr_status,
        "response_time": f"{cbr_time:.3f}s"
    }
    if cbr_status != "healthy" and overall_status == "healthy":
        overall_status = "degraded"

    return HealthCheckResponse(
        status=overall_status,
        version="1.0.0",
        timestamp=timestamp,
        checks=checks
    )


async def _measure_component(check_func):
    """Общий хелпер для проверки компонента с измерением времени."""
    start_time = time.time()
    try:
        status = await check_func()
    except Exception:
        status = "unhealthy"
    return status, time.time() - start_time


async def _check_database() -> str:
    """Проверить здоровье базы данных."""
    async with AsyncSessionLocal() as session:
        await session.execute(text("SELECT 1"))
    return "healthy"


async def _check_cbr_api() -> str:
    """Проверить доступность CBR API."""
    cbr_provider = CBRCurrencyRatesProvider()
    async with cbr_provider:
        rate = await cbr_provider.get_usd_to_rub_rate()
    return "healthy" if rate else "degraded"


@router.get(
    "/ping",
    summary="Простая проверка доступности",
    description="Быстрая проверка что сервис отвечает"
)
async def ping():
    """Простая проверка доступности."""
    return {"status": "ok", "timestamp": datetime.utcnow().isoformat() + "Z"}
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\routers\packages.py --------------------
"""
Роутер для работы с посылками.
POST /packages (регистрация), GET /packages (листинг), GET /packages/{id}
"""
from fastapi import APIRouter, Depends, HTTPException, Query, Response
from typing import Optional

from presentation.schemas.package_schemas import (
    RegisterPackageRequest, 
    RegisterPackageResponse,
    PackageListResponse,
    PackageDetailsResponse,
    PackageListItem
)
from presentation.schemas.error_schemas import ErrorResponse
from presentation.dependencies.session_deps import auto_session, require_session
from application.use_cases.register_package import RegisterPackageUseCase
from application.use_cases.get_packages import GetPackagesUseCase
from application.use_cases.get_package_details import GetPackageDetailsUseCase
from application.contracts.package_dto import CreatePackageDTO, PackageFilterDTO
from core.exceptions import AppError, ValidationError, NotFoundError
from infrastructure.tasks.delivery_tasks import calculate_delivery_prices, get_packages_without_price_count


router = APIRouter()

# TODO: Dependency Injection уже настроен
from presentation.dependencies.di_deps import (
    get_register_package_use_case,
    get_get_packages_use_case,
    get_get_package_details_use_case
)


@router.post(
    "/packages", 
    response_model=RegisterPackageResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Ошибка валидации"},
        500: {"model": ErrorResponse, "description": "Внутренняя ошибка сервера"}
    },
    summary="Зарегистрировать посылку",
    description="Регистрирует новую посылку и возвращает её ID"
)
async def register_package(
    request: RegisterPackageRequest,
    response: Response,
    session_id: str = Depends(auto_session),
    use_case: RegisterPackageUseCase = Depends(get_register_package_use_case)
):
    """Зарегистрировать новую посылку."""
    try:
        # Создаем DTO
        create_dto = CreatePackageDTO(
            name=request.name,
            weight=request.weight,
            type_id=request.type_id,
            value_usd=request.value_usd,
            session_id=session_id
        )
        
        # Выполняем use case
        package_dto = await use_case.execute(create_dto)
        # Тригерим асинхронный перерасчет цен (для видимости в Celery)
        try:
            calculate_delivery_prices.delay(1)
        except Exception:
            # Игнорируем сбои публикации, чтобы не ломать основной поток
            pass
        
        return RegisterPackageResponse(
            id=package_dto.id,
            message="Посылка успешно зарегистрирована"
        )
        
    except ValidationError as e:
        raise HTTPException(
            status_code=400,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
    except AppError as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )


@router.get(
    "/packages", 
    response_model=PackageListResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Ошибка валидации"},
        401: {"model": ErrorResponse, "description": "Сессия не найдена"}
    },
    summary="Получить список посылок",
    description="Возвращает список посылок пользователя с фильтрацией и пагинацией"
)
async def get_packages(
    session_id: str = Depends(require_session),
    type_id: Optional[int] = Query(None, description="Фильтр по типу посылки"),
    has_price: Optional[bool] = Query(None, description="Фильтр по наличию цены"),
    page: int = Query(1, ge=1, description="Номер страницы"),
    size: int = Query(20, ge=1, le=100, description="Размер страницы"),
    use_case: GetPackagesUseCase = Depends(get_get_packages_use_case)
):
    """Получить список посылок пользователя."""
    try:
        # Параллельно публикуем мониторинговую задачу (для видимости в Celery/Flower)
        try:
            get_packages_without_price_count.delay()
        except Exception:
            pass
        # Создаем DTO фильтров
        filters = PackageFilterDTO(
            session_id=session_id,
            type_id=type_id,
            has_price=has_price,
            offset=(page - 1) * size,
            limit=size
        )
        
        # Выполняем use case
        pagination_result = await use_case.execute(filters)
        
        # Конвертируем в схемы ответа
        items = []
        for item_dto in pagination_result.items:
            items.append(PackageListItem(
                id=item_dto.id,
                name=item_dto.name,
                weight=item_dto.weight,
                type_id=item_dto.type_id,
                type_name=item_dto.type_name,
                value_usd=item_dto.value_usd,
                delivery_price_rub=item_dto.delivery_price_rub,
                delivery_status=item_dto.status,
                created_at=item_dto.created_at
            ))
        
        return PackageListResponse(
            items=items,
            total=pagination_result.total,
            page=pagination_result.page,
            pages=pagination_result.pages,
            has_next=pagination_result.has_next,
            has_prev=pagination_result.has_prev
        )
        
    except ValidationError as e:
        raise HTTPException(
            status_code=400,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
    except AppError as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )


@router.get(
    "/packages/{package_id}", 
    response_model=PackageDetailsResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Ошибка валидации"},
        401: {"model": ErrorResponse, "description": "Сессия не найдена"},
        404: {"model": ErrorResponse, "description": "Посылка не найдена"}
    },
    summary="Получить детали посылки",
    description="Возвращает полную информацию о посылке по её ID"
)
async def get_package_details(
    package_id: int,
    session_id: str = Depends(require_session),
    use_case: GetPackageDetailsUseCase = Depends(get_get_package_details_use_case)
):
    """Получить детали посылки."""
    try:
        # Выполняем use case
        package_dto = await use_case.execute(package_id, session_id)
        
        # Определяем статус
        delivery_status = "calculated" if package_dto.delivery_price_rub else "pending"
        status_text = "Рассчитано" if package_dto.delivery_price_rub else "Не рассчитано"
        # Если цена не рассчитана, публикуем задачу расчета (для отображения в Celery)
        if not package_dto.delivery_price_rub:
            try:
                calculate_delivery_prices.delay()
            except Exception:
                pass
        
        return PackageDetailsResponse(
            id=package_dto.id,
            name=package_dto.name,
            weight=package_dto.weight,
            type_id=package_dto.type_id,
            type_name=package_dto.type_name or "Неизвестный",
            value_usd=package_dto.value_usd,
            delivery_price_rub=package_dto.delivery_price_rub,
            delivery_status=delivery_status,
            created_at=package_dto.created_at
        )
        
    except ValidationError as e:
        raise HTTPException(
            status_code=400,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=404,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
    except AppError as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\routers\package_types.py --------------------
"""
Роутер для работы с типами посылок.
GET /package-types - получить все типы посылок
"""
from fastapi import APIRouter, Depends, HTTPException
from typing import List

from presentation.schemas.package_type_schemas import PackageTypesListResponse, PackageTypeResponse
from presentation.schemas.error_schemas import ErrorResponse
from application.use_cases.get_package_types import GetPackageTypesUseCase
from core.exceptions import AppError

router = APIRouter()

from presentation.dependencies.di_deps import get_get_package_types_use_case


@router.get(
    "/package-types",
    response_model=PackageTypesListResponse,
    responses={
        500: {"model": ErrorResponse, "description": "Внутренняя ошибка сервера"}
    },
    summary="Получить типы посылок",
    description="Возвращает список всех доступных типов посылок"
)
async def get_package_types(
    use_case: GetPackageTypesUseCase = Depends(get_get_package_types_use_case)
):
    """Получить все типы посылок."""
    try:
        # Выполняем use case
        package_types = await use_case.execute()
        
        # Конвертируем в схемы ответа
        types = []
        for package_type in package_types:
            types.append(PackageTypeResponse(
                id=package_type.id,
                name=package_type.name,
                display_name=package_type.display_name
            ))
        
        return PackageTypesListResponse(
            types=types,
            total=len(types)
        )
        
    except AppError as e:
        raise HTTPException(
            status_code=500,
            detail={
                "error": True,
                "message": e.message,
                "error_code": e.error_code,
                "details": e.details
            }
        )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\routers\__init__.py --------------------
"""Инициализация модуля presentation/routers."""

from . import packages, package_types, delivery, health

__all__ = [
    "packages",
    "package_types", 
    "delivery",
    "health"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\delivery_schemas.py --------------------
"""
Схемы для работы с доставкой и периодическими задачами.
"""
from decimal import Decimal
from typing import Optional
from pydantic import BaseModel, Field


class TriggerCalculationRequest(BaseModel):
    """Схема запроса на принудительный расчет цен."""
    
    limit: Optional[int] = Field(
        100, 
        ge=1, 
        le=1000,
        description="Максимальное количество посылок для обработки"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "limit": 100
            }
        }


class TriggerCalculationResponse(BaseModel):
    """Схема ответа после запуска расчета цен."""
    
    task_id: str = Field(..., description="ID задачи")
    message: str = Field(..., description="Сообщение о запуске")
    packages_count: int = Field(..., description="Количество посылок к обработке")
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                "message": "Расчет цен запущен",
                "packages_count": 25
            }
        }


class ExchangeRateResponse(BaseModel):
    """Схема ответа с текущим курсом доллара."""
    
    task_id: Optional[str] = Field(None, description="ID Celery-задачи обновления курсов (если запущена)")
    rate: Decimal = Field(..., description="Курс USD/RUB")
    source: str = Field(..., description="Источник курса")
    cached: bool = Field(..., description="Получен из кэша")
    updated_at: Optional[str] = Field(None, description="Время последнего обновления")
    
    class Config:
        json_encoders = {
            Decimal: str
        }
        json_schema_extra = {
            "example": {
                "task_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                "rate": "95.67",
                "source": "CBR",
                "cached": True,
                "updated_at": "2025-08-28T12:00:00Z"
            }
        }
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\error_schemas.py --------------------
"""
Pydantic схемы для стандартизации ошибок API.
"""
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field


class ErrorDetail(BaseModel):
    """Детали ошибки."""
    
    field: Optional[str] = Field(None, description="Поле с ошибкой")
    message: str = Field(..., description="Сообщение об ошибке")
    code: Optional[str] = Field(None, description="Код ошибки")


class ErrorResponse(BaseModel):
    """Стандартная схема ответа с ошибкой."""
    
    error: bool = Field(True, description="Флаг ошибки")
    message: str = Field(..., description="Основное сообщение об ошибке")
    error_code: str = Field(..., description="Код ошибки")
    details: Optional[Dict[str, Any]] = Field(
        None, 
        description="Дополнительные детали ошибки"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": True,
                "message": "Ошибка валидации данных",
                "error_code": "VALIDATION_ERROR",
                "details": {
                    "field": "weight",
                    "message": "Вес должен быть больше нуля"
                }
            }
        }


class ValidationErrorResponse(BaseModel):
    """Схема ответа с ошибками валидации."""
    
    error: bool = Field(True, description="Флаг ошибки")
    message: str = Field(
        default="Ошибка валидации данных", 
        description="Основное сообщение"
    )
    error_code: str = Field(
        default="VALIDATION_ERROR", 
        description="Код ошибки"
    )
    errors: list[ErrorDetail] = Field(..., description="Список ошибок валидации")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error": True,
                "message": "Ошибка валидации данных",
                "error_code": "VALIDATION_ERROR",
                "errors": [
                    {
                        "field": "weight",
                        "message": "Вес должен быть больше нуля",
                        "code": "value_error.number.not_gt"
                    }
                ]
            }
        }


class SuccessResponse(BaseModel):
    """Схема успешного ответа."""
    
    success: bool = Field(True, description="Флаг успеха")
    message: str = Field(..., description="Сообщение об успехе")
    data: Optional[Dict[str, Any]] = Field(
        None, 
        description="Дополнительные данные"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "Операция выполнена успешно",
                "data": {}
            }
        }
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\health_schemas.py --------------------
"""
Схемы для проверки здоровья сервиса.
"""
from typing import Dict, Any
from pydantic import BaseModel, Field


class HealthCheckResponse(BaseModel):
    """Схема ответа проверки здоровья."""
    
    status: str = Field(..., description="Статус сервиса")
    version: str = Field(..., description="Версия приложения")
    timestamp: str = Field(..., description="Время проверки")
    checks: Dict[str, Any] = Field(..., description="Результаты проверок")
    
    class Config:
        json_schema_extra = {
            "example": {
                "status": "healthy",
                "version": "1.0.0",
                "timestamp": "2025-08-28T12:00:00Z",
                "checks": {
                    "database": {"status": "healthy", "response_time": "0.05s"},
                    "cbr_api": {"status": "healthy", "response_time": "0.20s"}
                }
            }
        }
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\package_schemas.py --------------------
"""
Pydantic схемы для работы с посылками в API.
Валидация входящих запросов и форматирование ответов.
"""
from decimal import Decimal
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field, validator


class RegisterPackageRequest(BaseModel):
    """Схема запроса на регистрацию посылки."""
    
    name: str = Field(
        ..., 
        min_length=1, 
        max_length=200,
        description="Название посылки"
    )
    weight: Decimal = Field(
        ..., 
        gt=0, 
        decimal_places=3,
        description="Вес посылки в килограммах"
    )
    type_id: int = Field(
        ..., 
        ge=1, 
        le=3,
        description="ID типа посылки (1-одежда, 2-электроника, 3-разное)"
    )
    value_usd: Decimal = Field(
        ..., 
        ge=0, 
        decimal_places=2,
        description="Стоимость содержимого в долларах"
    )
    
    @validator('name')
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Название посылки не может быть пустым')
        return v.strip()
    
    class Config:
        json_encoders = {
            Decimal: str
        }
        json_schema_extra = {
            "example": {
                "name": "Зимняя куртка",
                "weight": "1.250",
                "type_id": 1,
                "value_usd": "150.00"
            }
        }


class RegisterPackageResponse(BaseModel):
    """Схема ответа после регистрации посылки."""
    
    id: int = Field(..., description="Уникальный ID посылки")
    message: str = Field(default="Посылка успешно зарегистрирована")
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": 123,
                "message": "Посылка успешно зарегистрирована"
            }
        }


class PackageDetailsResponse(BaseModel):
    """Схема ответа с деталями посылки."""
    
    id: int = Field(..., description="ID посылки")
    name: str = Field(..., description="Название посылки")
    weight: Decimal = Field(..., description="Вес в килограммах")
    type_id: int = Field(..., description="ID типа посылки")
    type_name: str = Field(..., description="Название типа посылки")
    value_usd: Decimal = Field(..., description="Стоимость в долларах")
    delivery_price_rub: Optional[Decimal] = Field(
        None, 
        description="Стоимость доставки в рублях"
    )
    delivery_status: str = Field(..., description="Статус расчета доставки")
    created_at: datetime = Field(..., description="Дата создания")
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }
        json_schema_extra = {
            "example": {
                "id": 123,
                "name": "Зимняя куртка",
                "weight": "1.250",
                "type_id": 1,
                "type_name": "Одежда",
                "value_usd": "150.00",
                "delivery_price_rub": "1875.50",
                "delivery_status": "calculated",
                "created_at": "2025-08-28T12:00:00"
            }
        }


class PackageListItem(BaseModel):
    """Схема элемента списка посылок."""
    
    id: int = Field(..., description="ID посылки")
    name: str = Field(..., description="Название посылки") 
    weight: Decimal = Field(..., description="Вес в килограммах")
    type_id: int = Field(..., description="ID типа посылки")
    type_name: str = Field(..., description="Название типа посылки")
    value_usd: Decimal = Field(..., description="Стоимость в долларах")
    delivery_price_rub: Optional[Decimal] = Field(
        None, 
        description="Стоимость доставки в рублях"
    )
    delivery_status: str = Field(..., description="Статус расчета доставки")
    created_at: datetime = Field(..., description="Дата создания")
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class PackageListResponse(BaseModel):
    """Схема ответа со списком посылок."""
    
    items: List[PackageListItem] = Field(..., description="Список посылок")
    total: int = Field(..., description="Общее количество посылок")
    page: int = Field(..., description="Текущая страница")
    pages: int = Field(..., description="Общее количество страниц")
    has_next: bool = Field(..., description="Есть ли следующая страница")
    has_prev: bool = Field(..., description="Есть ли предыдущая страница")
    
    class Config:
        schema_extra = {
            "example": {
                "items": [
                    {
                        "id": 123,
                        "name": "Зимняя куртка",
                        "weight": "1.250",
                        "type_id": 1,
                        "type_name": "Одежда",
                        "value_usd": "150.00",
                        "delivery_price_rub": "1875.50",
                        "delivery_status": "calculated",
                        "created_at": "2025-08-28T12:00:00"
                    }
                ],
                "total": 1,
                "page": 1,
                "pages": 1,
                "has_next": False,
                "has_prev": False
            }
        }


class PackageFilters(BaseModel):
    """Схема фильтров для поиска посылок."""
    
    type_id: Optional[int] = Field(
        None, 
        ge=1, 
        le=3,
        description="Фильтр по типу посылки"
    )
    has_price: Optional[bool] = Field(
        None,
        description="Фильтр по наличию рассчитанной цены доставки"
    )
    page: int = Field(
        1, 
        ge=1,
        description="Номер страницы"
    )
    size: int = Field(
        20, 
        ge=1, 
        le=100,
        description="Размер страницы"
    )
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\package_type_schemas.py --------------------
"""
Pydantic схемы для работы с типами посылок в API.
"""
from typing import List
from pydantic import BaseModel, Field


class PackageTypeResponse(BaseModel):
    """Схема ответа с информацией о типе посылки."""
    
    id: int = Field(..., description="ID типа посылки")
    name: str = Field(..., description="Системное название типа")
    display_name: str = Field(..., description="Человекочитаемое название")
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "clothes",
                "display_name": "Одежда"
            }
        }


class PackageTypesListResponse(BaseModel):
    """Схема ответа со списком всех типов посылок."""
    
    types: List[PackageTypeResponse] = Field(..., description="Список типов посылок")
    total: int = Field(..., description="Общее количество типов")
    
    class Config:
        json_schema_extra = {
            "example": {
                "types": [
                    {"id": 1, "name": "clothes", "display_name": "Одежда"},
                    {"id": 2, "name": "electronics", "display_name": "Электроника"},
                    {"id": 3, "name": "other", "display_name": "Другое"}
                ],
                "total": 3
            }
        }
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\presentation\schemas\__init__.py --------------------
"""Инициализация модуля presentation/schemas."""

from . import package_schemas, package_type_schemas, error_schemas, delivery_schemas, health_schemas

__all__ = [
    "package_schemas",
    "package_type_schemas",
    "error_schemas", 
    "delivery_schemas",
    "health_schemas"
]
.
-------------------- C:\Users\Corvus\OneDrive\Рабочий стол\App\Delivery-App\tests\test_delivery_pricing.py --------------------
from decimal import Decimal

from domain.entities.package import Package
from domain.services.delivery_pricing import DeliveryPricingService
from domain.value_objects.currency import Rate
from domain.value_objects.identifiers import PackageId


def test_calculate_delivery_price_basic():
    svc = DeliveryPricingService()
    pkg = Package(
        id=PackageId.from_int(1),
        name="Test",
        weight=Decimal("2.000"),
        type_id=1,
        value_usd=Decimal("100.00"),
        session_id="00000000-0000-0000-0000-000000000000",
    )
    rate = Rate.usd_to_rub(Decimal("90.00"))

    price = svc.calculate_delivery_price(pkg, rate)

    # (2 * 0.5 + 100 * 0.01) * 90 = (1 + 1) * 90 = 180.00
    assert price == Decimal("180.00")
.
=== Done: 01.09.2025  8:45:14,99
